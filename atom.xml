<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张副官</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zhangfuguan.top/"/>
  <updated>2021-04-13T16:51:51.503Z</updated>
  <id>http://www.zhangfuguan.top/</id>
  
  <author>
    <name>张副官</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>搞定算法之快速排序</title>
    <link href="http://www.zhangfuguan.top/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.zhangfuguan.top/2021/04/14/搞定算法之快速排序/</id>
    <published>2021-04-13T16:09:06.000Z</published>
    <updated>2021-04-13T16:51:51.503Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>输入一组数组，使用快速排序算法对其进行排序</p></blockquote><ul><li>示例1</li></ul><p>输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;5，7，2，9，10，4&#125;</span><br></pre></td></tr></table></figure></p><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;2，4，5，7，9，10&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ol><li><p>取第一个作为基准数</p></li><li><p>将小于pri的数放在基准数的左边，将大于基准数的放在其右边</p></li><li><p>以基准数为界限，将之前的川切割成两个字串</p></li><li><p>分别对两个字串递归执行步骤1，2，3</p></li></ol><h3 id="解题思维"><a href="#解题思维" class="headerlink" title="解题思维"></a>解题思维</h3><p>对于</p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-21-35.png" alt></p><ol><li>pri为第一个元素值, left为第一个元素下标， right为最后一个元素下标</li></ol><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-26-25.png" alt></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">pri = arr[left]</span><br><span class="line">right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="2"><li>从最右边开始，如果right指向的值大于则right减1，否则就将当前right所指向的值放在left位置，然后执行3。如此循环一直到left=right.</li></ol><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-40-15.png" alt></p><ol start="3"><li>从最左边开始,如果right指向的值大于则right加1，否则就将当前left所指向的值放在right位置，然后执行2。如此循环一直到left=right.</li></ol><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-42-35.png" alt></p><ol start="4"><li>上面循环执行的展示过程</li></ol><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-43-45.png" alt></p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-44-23.png" alt></p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-45-10.png" alt></p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-45-30.png" alt></p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-46-23.png" alt></p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-46-52.png" alt></p><ol start="5"><li>当left=right, 那么就把基准值赋给left位置,至此就完成了把小于基准值放在左侧，大于基准值放在右侧的任务。</li></ol><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-48-02.png" alt></p><ol start="6"><li>然后以上面left将原数组切割成两个字串，分别递归执行上面的步骤</li></ol><h3 id="源码理解更深刻"><a href="#源码理解更深刻" class="headerlink" title="源码理解更深刻"></a>源码理解更深刻</h3><blockquote><p>强烈建议自己看懂之后手动实现一篇</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partion</span><span class="params">(arr []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">pri := arr[left]</span><br><span class="line">fmt.Printf(<span class="string">&quot;left: %d, right: %d&quot;</span>, left, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line"><span class="keyword">for</span> left &lt; right &amp;&amp; arr[right] &gt;= pri &#123;</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line">arr[left] = arr[right]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> left &lt; right &amp;&amp; arr[left] &lt;= pri &#123;</span><br><span class="line">left++</span><br><span class="line">&#125;</span><br><span class="line">arr[right] = arr[left]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">arr[left] = pri</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="keyword">int</span>, left, right <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">par := partion(arr, left, right)</span><br><span class="line">fmt.Println(par)</span><br><span class="line"></span><br><span class="line">QuickSort(arr, left, par<span class="number">-1</span>)</span><br><span class="line">QuickSort(arr, par+<span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;输入一组数组，使用快速排序算法对其进行排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://www.zhangfuguan.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="算法" scheme="http://www.zhangfuguan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>反转链表</title>
    <link href="http://www.zhangfuguan.top/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.zhangfuguan.top/2021/04/11/反转链表/</id>
    <published>2021-04-11T14:31:01.000Z</published>
    <updated>2021-04-11T16:52:20.884Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。</p></blockquote><ul><li>示例1</li></ul><p>输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure></p><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;3,2,1&#125;</span><br></pre></td></tr></table></figure><p>直观来看对于链表：</p><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-11-23-46-30.png" alt="01"></p><p>反转后</p><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-11-23-49-49.png" alt="1"></p><h3 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h3><ol><li>其实我们本质上是把每个节点的数据之间的指向调整一下</li></ol><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-11-23-56-37.png" alt="3"></p><ol start="2"><li>通常我们使用preNode(前一个节点)，currNode(当前节点)，nextNode(当前节点)来实现遍历每个节点修改。最开始preNode指向null，currNode与nextNode指向第一个节点。</li></ol><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-12-00-14-42.png" alt></p><ol start="3"><li><p>现在开始第一个反转：</p><p> 将nextNode指针指向下一个节点</p><p> <img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-12-00-19-09.png" alt></p><p> 修改当前指针的方向</p><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-12-00-20-50.png" alt></p><p>方向修改完成，将pre指向当前节点</p><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-12-00-21-30.png" alt></p><p>将当前节点移动到下一个节点上</p><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-12-00-22-24.png" alt></p></li></ol><ol start="3"><li>直到currNode不为null。总结来说preNode用来维持与已经反转好的那部分的关系，nextNode是为了currNode完成方向逆转之后跳到下一个节点，currNode完成方向逆转，承接preNode。想一想如果没有nextNode行不行？</li></ol><h4 id="源码（golang）"><a href="#源码（golang）" class="headerlink" title="源码（golang）"></a>源码（golang）</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Link 链表</span></span><br><span class="line"><span class="keyword">type</span> Link <span class="keyword">struct</span> &#123;</span><br><span class="line">Value <span class="keyword">int</span></span><br><span class="line">Next  *Link</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt; preNode, curNode, nextNode</span></span><br><span class="line"><span class="comment">1. nextNode = curNode.Next</span></span><br><span class="line"><span class="comment">2. curNode.Next = preNode</span></span><br><span class="line"><span class="comment">3. preNode = curNode</span></span><br><span class="line"><span class="comment">4. curNode = nextNode</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// ReversalLink 反转链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReversalLink</span><span class="params">(head *Link)</span> *<span class="title">Link</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> preNode *Link</span><br><span class="line"><span class="keyword">var</span> nextNode *Link</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">nextNode = head.Next</span><br><span class="line">head.Next = preNode</span><br><span class="line">preNode = head</span><br><span class="line">head = nextNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> preNode</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><ol><li>以heap为起点进行反转，然后返回新链表的起点元素。</li></ol><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-12-00-51-09.png" alt></p><ol start="2"><li>注意第一个元素需要做单独处理</li></ol><h4 id="源码（golang）-1"><a href="#源码（golang）-1" class="headerlink" title="源码（golang）"></a>源码（golang）</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Link 链表</span></span><br><span class="line"><span class="keyword">type</span> Link <span class="keyword">struct</span> &#123;</span><br><span class="line">Value <span class="keyword">int</span></span><br><span class="line">Next  *Link</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReversalLinkRecursion 递归反转全部链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReversalLinkRecursion</span><span class="params">(head *Link)</span> *<span class="title">Link</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;bbbb&quot;</span>)</span><br><span class="line"></span><br><span class="line">lastLink := ReversalLink(head.Next)</span><br><span class="line">fmt.Println(<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line">head.Next.Next = head</span><br><span class="line">head.Next = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> lastLink</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;输入一个链表，反转链表后，输出新链表的表头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://www.zhangfuguan.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="算法" scheme="http://www.zhangfuguan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>武汉大学生落户流程</title>
    <link href="http://www.zhangfuguan.top/2021/04/04/%E6%AD%A6%E6%B1%89%E5%A4%A7%E5%AD%A6%E7%94%9F%E8%90%BD%E6%88%B7%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.zhangfuguan.top/2021/04/04/武汉大学生落户流程/</id>
    <published>2021-04-04T13:39:16.000Z</published>
    <updated>2021-04-04T13:42:16.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="武汉大学生落户"><a href="#武汉大学生落户" class="headerlink" title="武汉大学生落户"></a>武汉大学生落户</h2><h3 id="大学生资格"><a href="#大学生资格" class="headerlink" title="大学生资格"></a>大学生资格</h3><p>简而言之，基本上门槛很低。</p><ul><li><p>无年龄限制人员–博士、硕士、研究生(含教育部认证的留学回国人员)学历</p></li><li><p>不满45岁人员–专科及本科学历或学位</p></li></ul><h3 id="落户流程"><a href="#落户流程" class="headerlink" title="落户流程"></a>落户流程</h3><p><img src="/2021/04/04/%E6%AD%A6%E6%B1%89%E5%A4%A7%E5%AD%A6%E7%94%9F%E8%90%BD%E6%88%B7%E6%B5%81%E7%A8%8B/wh-house01.png" alt="wh-house01"></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>准迁入证明有40个工作日的有效期</li><li>能选择邮寄就邮寄，方便很多</li></ol><h3 id="资料准备"><a href="#资料准备" class="headerlink" title="资料准备"></a>资料准备</h3><ol><li>申报户口登记表（自取链接: <a href="https://pan.baidu.com/s/1zo_mPdzedxYe4qiegV6BEw">https://pan.baidu.com/s/1zo_mPdzedxYe4qiegV6BEw</a>  密码: c9vh）</li><li>户口本首页以及本人页</li><li>学历证明（学信网开具）</li><li>毕业证原件</li><li>居住协议（租赁或借住合同）</li><li>本人照片</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;武汉大学生落户&quot;&gt;&lt;a href=&quot;#武汉大学生落户&quot; class=&quot;headerlink&quot; title=&quot;武汉大学生落户&quot;&gt;&lt;/a&gt;武汉大学生落户&lt;/h2&gt;&lt;h3 id=&quot;大学生资格&quot;&gt;&lt;a href=&quot;#大学生资格&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="生活" scheme="http://www.zhangfuguan.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="房子" scheme="http://www.zhangfuguan.top/tags/%E6%88%BF%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>每日一招之golang的append</title>
    <link href="http://www.zhangfuguan.top/2021/04/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%8B%9B%E4%B9%8Bgolang%E7%9A%84append/"/>
    <id>http://www.zhangfuguan.top/2021/04/04/每日一招之golang的append/</id>
    <published>2021-04-04T13:32:14.000Z</published>
    <updated>2021-04-04T13:32:58.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="请说出一下打印结果"><a href="#请说出一下打印结果" class="headerlink" title="请说出一下打印结果"></a>请说出一下打印结果</h3><ul><li><p>第一种</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sli := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">sli[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">sli[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">res := changeSlice(sli)</span><br><span class="line">fmt.Printf(<span class="string">&quot;sli: %+v, res: %+v \n&quot;</span>, sli, res)</span><br><span class="line"></span><br><span class="line">res[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;sli: %+v, res: %+v \n&quot;</span>, sli, res)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(s []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  test2  go run main.go</span><br><span class="line">sli: [0 1], res: [0 1 3] </span><br><span class="line">sli: [100 1], res: [100 1 3] </span><br></pre></td></tr></table></figure><ul><li>当sli传递给函数的时候，新建了切片s。在函数中给s进行了append一个元素，由于此时s的容量足够到，并没有生成新的底层数组。当修改返回的res的时候，res与sli共用了底层的数组，因此修改ret的原始，相应的也看到了slice的改变。</li></ul></li></ul><ul><li><p>第二种</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sli := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">sli[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">sli[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">res := changeSlice(sli)</span><br><span class="line">fmt.Printf(<span class="string">&quot;sli: %+v, res: %+v \n&quot;</span>, sli, res)</span><br><span class="line"></span><br><span class="line">res[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;sli: %+v, res: %+v \n&quot;</span>, sli, res)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(s []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">☁  test2  go run main.go</span><br><span class="line">sli: [0 1], res: [0 1 3] </span><br><span class="line">sli: [0 1], res: [100 1 3] </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>函数中先改变s第一个元素的值，由于slice和s都共用了底层数组，因此无论原始切片slice还是ret，第一个元素都是-1.然后append操作之后，因为超出了s的容量，因此会新建底层数组，虽然s变量没变，但是他的底层数组变了，此时修改s第一个元素，并不会影响原始的slice切片。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>切片底层本质是基于数组</p></li><li><p>append的是用来向切片添加数据的，当前切片容量够的时候，append生成的心切片依然和之前的切片共享底层数组，一旦当前切片的容量不够用的时候就会另起灶炉，生成新的底层数组。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;请说出一下打印结果&quot;&gt;&lt;a href=&quot;#请说出一下打印结果&quot; class=&quot;headerlink&quot; title=&quot;请说出一下打印结果&quot;&gt;&lt;/a&gt;请说出一下打印结果&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一种&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="每日一招" scheme="http://www.zhangfuguan.top/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>利用pprof排查内存泄漏</title>
    <link href="http://www.zhangfuguan.top/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://www.zhangfuguan.top/2020/11/14/利用pprof排查内存泄漏/</id>
    <published>2020-11-14T14:54:21.000Z</published>
    <updated>2021-04-04T13:17:14.788Z</updated>
    
    <content type="html"><![CDATA[<h3 id="go技能卡：利用pprof排查内存泄漏"><a href="#go技能卡：利用pprof排查内存泄漏" class="headerlink" title="go技能卡：利用pprof排查内存泄漏"></a>go技能卡：利用pprof排查内存泄漏</h3><h4 id="浅言碎语"><a href="#浅言碎语" class="headerlink" title="浅言碎语"></a>浅言碎语</h4><blockquote><p>前几天在POC环境，我负责的一个项目的调度程序内存出现线性增长，由于我们的常驻内存程序限制最大为256MB，所以增长超过这个限制的时候就会被kill掉。</p></blockquote><p> <img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/b81ff3d4-7b11-40c8-b791-fc7654768fd6.png" alt></p><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/99cce23b-a5e1-4716-b702-6718911d1911.png" alt></p><blockquote><p>明明DEV, TEST两个环境都是正确的，为啥POC就出现异常了呢？正当我们焦头烂额的时候，想起来我之前在程序里面已经开启了pprof数据采集服务，最终我们通过pprof找到问题位置，排查发现有一位同学在for循环开启了context之后没有关闭掉，使得内存一直增长，添加闭包之后得以解决。</p></blockquote><h4 id="关于pprof"><a href="#关于pprof" class="headerlink" title="关于pprof"></a>关于pprof</h4><blockquote><p>pprof是提供应用运行状态（CPU, 内存，Goroutine, 锁等）数据和可视化分析的工具。目前pprof提供了两种方式</p></blockquote><ul><li>runtime/pprof</li><li>net/http/pprof</li></ul><blockquote><p>其实<code>net/http/pprof</code>本内部也是使用<code>runtime/pprof</code>来实现，只不过是可以通过端口的方式暴露访问。本文主要讲述<code>net/http/pprof</code>的使用方法。参考<a href="[https://pkg.go.dev/net/http/pprof](https://pkg.go.dev/net/http/pprof">net/http/pprof</a>。</p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><blockquote><p>最简单的使用是在你的main函数里面导入<code>net/http/pprof</code>包，并监听一个端口号。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    helloHandler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        io.WriteString(w, <span class="string">&quot;Hello, world!\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>让后在浏览器中访问链接：<a href="http://127.0.0.1:8080/debug/pprof/">http://127.0.0.1:8080/debug/pprof/</a>可以看到：</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/616230dd-fa1f-4151-824d-a0f714504112.png" alt></p><blockquote><p>下面讲述一下上面几个参数的意义</p></blockquote><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>allocs</td><td>内存分配情况的采样信息</td></tr><tr><td>blocks</td><td>阻塞操作情况的采样信息</td></tr><tr><td>cmdline</td><td>显示程序启动命令及参数</td></tr><tr><td>goroutine</td><td>当前所有协程的堆栈信息</td></tr><tr><td>heap</td><td>堆上内存使用情况的采样信息</td></tr><tr><td>mutex</td><td>锁争用情况的采样信息</td></tr><tr><td>profile</td><td>CPU 占用情况的采样信息</td></tr><tr><td>threadcreate</td><td>系统线程创建情况的采样信息</td></tr><tr><td>trace</td><td>程序运行跟踪信息</td></tr></tbody></table><blockquote><p>说实话上面的信息打开后可读性不高，满屏密密麻麻的字符，不仔细看根本没法找到需要的信息，此时我们可以使用<code>go tool</code>命令来查看自己需要的信息。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool http://127.0.0.1:8080/debug/pprof/指标</span><br></pre></td></tr></table></figure><blockquote><p>比如我们在cmd里面打开<code>go tool pprof http://127.0.0.1:8080/debug/pprof/allocs</code>,次数会进入待输入命令状态，如果想知道可以支持什么命令则可以输入<code>help</code>即可查看， 进一步如果想看该命令释放方法可以<code>help 命令</code>得到，比如下面输入<code>help list</code>之后：</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/a4cb0d17-6078-45d9-b37b-44178c926e08.png" alt></p><blockquote><p>通常情况下我们会使用<code>top</code>/<code>top10</code>/<code>top20</code>来查看当前指数程序占用排行。</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/afd61c47-54eb-4dbe-bca9-b33fb479abf9.png" alt></p><blockquote><p>如果我们需要查看具体占用位置，可以输入<code>list 关键字</code>，比如<code>list StartCPUProfile</code>:</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/0574d8b6-61c5-4979-a5ab-f343f02efe4c.png" alt></p><blockquote><p>此时我们就可以定位到问题了。</p></blockquote><h4 id="锦上添花"><a href="#锦上添花" class="headerlink" title="锦上添花"></a>锦上添花</h4><blockquote><p>其实使用上面的方式我们已经定位到问题位置，但是命令行终究不够直观，如果提供一个文档或者网页能够把数据统计处理统计给我们，那岂不是妙哉，现饭还是很香的。我们只能想想，而大佬早已实现，其实<code>pprof</code>已经提供了网页方式浏览。我们只需要在上面的命令添加<code>-web</code>即可。但是如果你是第一次使用，则会出现以下问题：</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/b27472ea-1e52-443a-9860-7c7380a7970b.png" alt></p><blockquote><p>其实是提示我们需要安装<code>Graphviz</code>,Graphviz是一个由AT&amp;T实验室启动的开源工具包，用于绘制DOT语言脚本描述的图形。我们需要安装一下，(下载地址)[<a href="https://graphviz.org/download/">https://graphviz.org/download/</a>]。</p></blockquote><blockquote><p>安装之后重新执行<code>go tool pprof -web http://127.0.0.1:8080/debug/pprof/allocs</code></p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/2682fb43-3e97-41f9-a1bf-516892043742.png" alt></p><blockquote><p>上面其实是在浏览器中打开文件，其实还有更好的一种方式，利用<code>pprof</code>起一个服务，可以实时看到指标信息， 执行<code>go tool pprof -web http://127.0.0.1:8080/debug/pprof/allocs</code>:</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/ec476eaa-1768-4b91-ae70-a5342ff834f4.png" alt></p><blockquote><p>你可以选择上面的<code>TOP</code>查看排行情况：</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/8eb61e24-b372-481d-90cb-d51292ae78a8.png" alt></p><blockquote><p>你还可以选择<code>Peek</code>查看调用详情：</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/832add00-e1d8-4ea4-b00f-82ca1378047c.png" alt></p><blockquote><p>其实还有很多功能，比如查看火焰图，查看当前数据和累计数据等。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;go技能卡：利用pprof排查内存泄漏&quot;&gt;&lt;a href=&quot;#go技能卡：利用pprof排查内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;go技能卡：利用pprof排查内存泄漏&quot;&gt;&lt;/a&gt;go技能卡：利用pprof排查内存泄漏&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go并发控制方式</title>
    <link href="http://www.zhangfuguan.top/2020/10/15/go%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.zhangfuguan.top/2020/10/15/go并发控制方式/</id>
    <published>2020-10-14T16:25:17.000Z</published>
    <updated>2021-04-04T13:33:46.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Go并发控制模型"><a href="#Go并发控制模型" class="headerlink" title="Go并发控制模型"></a>Go并发控制模型</h3><h4 id="1-Sync"><a href="#1-Sync" class="headerlink" title="1. Sync"></a>1. Sync</h4><blockquote><p>分别使用sync.WaitGroup提供的Add，Done，Wait来控制计数器</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nameList := [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;zhang san&quot;</span>, <span class="string">&quot;li si&quot;</span>, <span class="string">&quot;wang wu&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="built_in">len</span>(nameList))</span><br><span class="line">    <span class="keyword">for</span> _, name := <span class="keyword">range</span> nameList &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Printf(<span class="string">&quot;name: %s \n&quot;</span>, name)</span><br><span class="line">        &#125;(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;over&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2. Channel"></a>2. Channel</h4><blockquote><p>通过channel阻塞实现</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nameList := [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;zhang san&quot;</span>, <span class="string">&quot;li si&quot;</span>, <span class="string">&quot;wang wu&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="built_in">len</span>(nameList))</span><br><span class="line">    <span class="keyword">for</span> _, name := <span class="keyword">range</span> nameList &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- <span class="number">1</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;name: %s \n&quot;</span>, name)</span><br><span class="line">        &#125;(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待N个后台线程完成</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(ch); i++ &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;over&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Context"><a href="#3-Context" class="headerlink" title="3. Context"></a>3. Context</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ctx, cancel :&#x3D; context.WithTimeout(context.Background(), time.Second*10)</span><br><span class="line">    go funcA(ctx)</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * 5)</span><br><span class="line">    cancel()</span><br><span class="line">    time.Sleep(time.Second * 5)</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;over&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func funcA(ctx context.Context) &#123;</span><br><span class="line">    go funcB(ctx)</span><br><span class="line">    for &#123;</span><br><span class="line">        time.Sleep(time.Second * 1)</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(&quot;funcA Stop&quot;)</span><br><span class="line">            return</span><br><span class="line">        default:</span><br><span class="line">            fmt.Println(&quot;doing funcA...&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func funcB(ctx context.Context) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        time.Sleep(time.Second * 1)</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(&quot;funcB Stop&quot;)</span><br><span class="line">            return</span><br><span class="line">        default:</span><br><span class="line">            fmt.Println(&quot;doing funcB...&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Go并发控制模型&quot;&gt;&lt;a href=&quot;#Go并发控制模型&quot; class=&quot;headerlink&quot; title=&quot;Go并发控制模型&quot;&gt;&lt;/a&gt;Go并发控制模型&lt;/h3&gt;&lt;h4 id=&quot;1-Sync&quot;&gt;&lt;a href=&quot;#1-Sync&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="并发" scheme="http://www.zhangfuguan.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>redis基本数据结构</title>
    <link href="http://www.zhangfuguan.top/2020/10/13/redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.zhangfuguan.top/2020/10/13/redis基本数据结构/</id>
    <published>2020-10-12T17:08:35.000Z</published>
    <updated>2021-04-04T13:17:14.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis面试系列：数据结构"><a href="#redis面试系列：数据结构" class="headerlink" title="redis面试系列：数据结构"></a>redis面试系列：数据结构</h3><blockquote><p>本文参考了《redis设计与实现》第二版</p></blockquote><h4 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h4><ul><li>常见数据类型<ul><li>string 字符串(简单动态字符串[sds],int整数)</li><li>list 列表(链表[linkedlist]，压缩表[ziplist])</li><li>hash 哈希（字典[hashtable]，压缩表[ziplist]）</li><li>set 集合（字典[hashtable], 整数集合[intset]）</li><li>zset 有序集合（跳跃表[skiplist], 压缩表[ziplist]）</li></ul></li><li>其他高级类型<ul><li>bitmap</li><li>HyperLogLog</li><li>Pub/Sub</li><li>Geo</li><li>BloomFilter</li></ul></li></ul><p>此文主要分析常见数据结构的应用场景、实现原理。</p><h4 id="2-简单动态字符串（SDS）"><a href="#2-简单动态字符串（SDS）" class="headerlink" title="2. 简单动态字符串（SDS）"></a>2. 简单动态字符串（SDS）</h4><p>&emsp;&emsp;redis是基于c语言实现的，但是redis的字符串却没有直接使用c语言的string类型，而是基于自己实现的简单字符串（simple dynamic string，简称sds）。sds的数据结构如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每一个字符串对应底层的sds是由三部分组成，分别是空闲空间长度，字符串长度，保存字符串的字节数组</li><li>free表示当前空闲的字节数，即空闲空间长度</li><li>len是用来保存当前字符串使用的字节长度，通常用来表示字符串的长度</li><li>redis的字符串在sds底层是通过字节数组的方式保存在buf当中</li></ul><p>为什么redis放着c语言现成的字符串类型不用，却自己去实现一套sds呢？从sds的数据结构可以看出它具备以下几个特点：<br> <img src="/2020/10/13/redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/sds.png" alt="redis基本数据结构"></p><p>（1）有效防止缓存区溢出</p><ul><li>SDS在执行修改之前会检查空间是否足够，如果不够用会自动将空间扩展</li></ul><p>（2）获取字符串长度的复杂度为O(1)</p><ul><li>SDS本身保存了自身的长度，所以直接获取就行</li></ul><p>（3）减少内存分配次数</p><ul><li>在C语言中，每次对字符的修改涉及到长度的变动时，都会发生系统对内存的操作（申请或释放）。SDS通过空间预分配和惰性释放极大减少了对内存的操作次数。</li><li>空间预分配：每次涉及到对字符串的操作时候，SDS不仅会为其分配修改所需要的空间，还会为SDS分配额外未使用的空间。</li><li>惰性释放：字符串长度缩短之后，不需要的空间不会立刻释放，而是分配到free空间里面，下次需要的时候直接获取，不需要重新分配内存。</li></ul><p>（4）二进制安全</p><ul><li>不同于C语言特殊的字符保存格式（字符串加末尾空字符），redis的SDS不会受限于任何格式，保存时候不会发生修改，所以它可以用来保存图片，视频等二进制数据。</li></ul><h4 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h4><p>&emsp;&emsp;C语言本身是没有链表这一数据结构，redis是自己实现的。链表提供了搞笑的节点重排，节点访问，节点增删能力。redis的列表底层实现之一就是链表，而且redis的发布与订阅，慢查询，监视器等功能也用到了链表，redis本身使用链表来保存多个客户端的状态。<br> <img src="/2020/10/13/redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/linkedlist.png" alt="redis基本数据结构"></p><h4 id="4-字典（map）"><a href="#4-字典（map）" class="headerlink" title="4. 字典（map）"></a>4. 字典（map）</h4><p>&emsp;&emsp;字典数据结构广泛应用于redis的各种功能当中，包括数据库和哈希键。redis中的字典使用哈希表作为底层实现，每个字典包含了两个哈希表，一个平时使用，一个是在rehash(扩展或收缩hash表)时用到。</p><h4 id="5-跳跃表（skiplist）"><a href="#5-跳跃表（skiplist）" class="headerlink" title="5. 跳跃表（skiplist）"></a>5. 跳跃表（skiplist）</h4><p>&emsp;&emsp;跳跃表是一种有序的数据结构，它通过在每个节点中维持指向其他节点的指针，从而拥有快速访问其他节点的能力。redis选择跳跃表作为有序集合的底层实现之一。</p><h4 id="6-整数集合（intset）"><a href="#6-整数集合（intset）" class="headerlink" title="6. 整数集合（intset）"></a>6. 整数集合（intset）</h4><p>&emsp;&emsp;整数集合是集合键的底层实现之一。当一个集合只用来保存整数，并且数量不是很多的时候，redis就会选择使用整数集合来实现。</p><h4 id="7-压缩表（ziplist）"><a href="#7-压缩表（ziplist）" class="headerlink" title="7. 压缩表（ziplist）"></a>7. 压缩表（ziplist）</h4><p>&emsp;&amp;emsp压缩表是列表和哈希两种数据类型的底层实现之一，压缩表是redis为了节约内存而开发的，它是由特殊编码的连续内存块组成的顺序数据结构。当一个列表只包含少量的键，并且每个键对应的值比较小的时候，redis就会使用压缩表来实现该列表。同样如果一个hash键只包含少量的值，则也会选择压缩表作为其底层实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis面试系列：数据结构&quot;&gt;&lt;a href=&quot;#redis面试系列：数据结构&quot; class=&quot;headerlink&quot; title=&quot;redis面试系列：数据结构&quot;&gt;&lt;/a&gt;redis面试系列：数据结构&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本文参考了《red
      
    
    </summary>
    
    
      <category term="redis" scheme="http://www.zhangfuguan.top/tags/redis/"/>
    
      <category term="数据库" scheme="http://www.zhangfuguan.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="http://www.zhangfuguan.top/2020/08/25/mysql%E7%B4%A2%E5%BC%95/"/>
    <id>http://www.zhangfuguan.top/2020/08/25/mysql索引/</id>
    <published>2020-08-24T16:54:11.000Z</published>
    <updated>2021-04-04T13:17:14.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mysql索引"><a href="#mysql索引" class="headerlink" title="mysql索引"></a>mysql索引</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul><li>数据库与表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_test` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `x` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `y` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `index_a_b_c_d` (`a`,`b`,`c`,`d`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure><h4 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>可以把索引理解为一本书的目录，可以通过目录迅速找到自己想要的章节，本质上就是为了提高查询速度。</p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>通常使用explain来分析一条sql语句中索引使用情况。后期会有章节专门介绍explain命令的使用方法。</p><ul><li><p>用法：<code>EXPLAIN SQL</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t_users where id&#x3D;1890 \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t_users</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h5 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h5><ul><li>对于重复度比较高的字段不适合做索引，比如性别，充其量就是男，女，其他，做索引作用不大。</li><li>创建合适的唯一索引</li><li>遵循最左匹配原则</li><li>对于经常用于排序（order by），分组（group by）的字段，我们可以建立索引</li><li>索引所在的列不能参与计算，不然会失效</li><li>尽量扩展索引，不要新增加索引。</li></ul><h4 id="普通索引（简单索引）"><a href="#普通索引（简单索引）" class="headerlink" title="普通索引（简单索引）"></a>普通索引（简单索引）</h4><p>最常见的索引之一，没有任何我约束。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(<span class="keyword">column</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- eg:</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_a <span class="keyword">ON</span> t_test(a);</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select * from t_test <span class="built_in">where</span> a=<span class="string">&#x27;123&#x27;</span> \G;</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t_test</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: index_a</span><br><span class="line">          key: index_a</span><br><span class="line">      key_len: 153</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="联合索引（符合索引）"><a href="#联合索引（符合索引）" class="headerlink" title="联合索引（符合索引）"></a>联合索引（符合索引）</h4><p>将多个字段用于创建索引。联合索引最重要的就是最左原则，他决定索引是否生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name(column1,column2,column3...);</span><br></pre></td></tr></table></figure><h5 id="索引最左原则"><a href="#索引最左原则" class="headerlink" title="索引最左原则"></a>索引最左原则</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(column1, column2);</span><br></pre></td></tr></table></figure><p>比如表t_test拥有字段<code>x,a,b,c,d,y</code>, 现在将字段<code>a,b,c,d</code>创建为联合索引，实际上是建立了<code>a</code>，<code>a,b</code>，<code>a,b,c</code>，<code>a,b,c,d</code>四个索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_a_b_c_d <span class="keyword">ON</span> t_test(a,b,c,d);</span><br></pre></td></tr></table></figure><ul><li><p>对于联合索引，mysql会依照创建索引时的字段顺序向右匹配，直到遇到范围查询（&gt;,&lt;,between,like）就停止匹配。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> b<span class="operator">=</span><span class="number">2</span> <span class="keyword">AND</span> c<span class="operator">&gt;</span><span class="number">3</span> <span class="keyword">AND</span> d<span class="operator">=</span><span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>此时<code>c</code> 无法使用索引。</p></li><li><p>对于查询中的<code>=</code>和<code>in</code>，只要<code>WHERE</code>里面对于索引字段的是<code>a</code>，<code>a,b</code>，<code>a,b,c</code>，<code>a,b,c,d</code>四种情况之一，那么字段条件后的字段顺序是不要求的， mysql会按照你创建索引字段顺序去比对。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> b<span class="operator">=</span><span class="number">2</span> <span class="keyword">AND</span> c<span class="operator">=</span><span class="number">3</span> <span class="keyword">AND</span> d<span class="operator">=</span><span class="number">6</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> c<span class="operator">=</span><span class="number">3</span> <span class="keyword">AND</span> d<span class="operator">=</span><span class="number">6</span> <span class="keyword">AND</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> b<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul><h5 id="有几个疑问"><a href="#有几个疑问" class="headerlink" title="有几个疑问"></a>有几个疑问</h5><p>对于上面（a,b,c,d）组成的联合索引</p><ul><li><p>A：以下索引会生效吗？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a,b,c,d,x <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> b<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> x<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>答案是不会生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT a,b,c,d,x FROM t_test WHERE b&#x3D;1 \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t_test</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>B：以下索引会生效吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT a,b,c,d FROM t_test WHERE b&#x3D;1 AND x&#x3D;5;</span><br></pre></td></tr></table></figure><p>答案是会生效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> a,b,c,d <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> b<span class="operator">=</span><span class="number">1</span> \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: t_test</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: index</span><br><span class="line">possible_keys: <span class="keyword">NULL</span></span><br><span class="line">          key: index_a_b_c_d</span><br><span class="line">      key_len: <span class="number">313</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"> </span><br><span class="line">ERROR:</span><br><span class="line"><span class="keyword">No</span> query specified</span><br></pre></td></tr></table></figure></li><li><p>B生效的原因在于查询条件中只有包含索引的字段，查询内容也全部在索引字段中，所以它只需要操作索引表即可。</p><p>A不生效是因为除了操作索引表之外，还需要从数据表中拿到额外的字段数据。</p></li></ul><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name ON table_name(column);</span><br></pre></td></tr></table></figure><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `table_name` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT ,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX index_name <span class="keyword">ON</span> table_name(<span class="keyword">column</span>)</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>使用索引的时候尽量不要使用like,  在语句<code>like value%</code>时索引会生效，但是<code>like %value%</code>不会生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t_test where a like &quot;a%&quot; \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t_test</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: index_a_b_c_d</span><br><span class="line">          key: index_a_b_c_d</span><br><span class="line">      key_len: 153</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from t_test where a like &quot;%a%&quot;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t_test</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>在索引列运算会导致索引失效</p></li><li><p>如果where后面的条件字段数据类型与匹配值的类型不一致，可能会导致索引失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_test <span class="keyword">where</span> a<span class="operator">=</span>&quot;1&quot;\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: t_test</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ref</span></span><br><span class="line">possible_keys: index_a_b_c_d</span><br><span class="line">          key: index_a_b_c_d</span><br><span class="line">      key_len: <span class="number">153</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_test <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span> \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: t_test</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ALL</span></span><br><span class="line">possible_keys: index_a_b_c_d</span><br><span class="line">          key: <span class="keyword">NULL</span></span><br><span class="line">      key_len: <span class="keyword">NULL</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">3</span> warnings (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>索引所在列的值不能为null。只有该列包含null值，则该索引列会失效。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mysql索引&quot;&gt;&lt;a href=&quot;#mysql索引&quot; class=&quot;headerlink&quot; title=&quot;mysql索引&quot;&gt;&lt;/a&gt;mysql索引&lt;/h3&gt;&lt;h4 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.zhangfuguan.top/tags/mysql/"/>
    
      <category term="索引" scheme="http://www.zhangfuguan.top/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>go内存管理</title>
    <link href="http://www.zhangfuguan.top/2020/08/16/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://www.zhangfuguan.top/2020/08/16/go内存管理/</id>
    <published>2020-08-15T16:29:58.000Z</published>
    <updated>2021-04-04T13:17:14.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GO内存管理"><a href="#GO内存管理" class="headerlink" title="GO内存管理"></a>GO内存管理</h3><h4 id="What"><a href="#What" class="headerlink" title="What ?"></a>What ?</h4><p>内存的分配，回收，释放的过程。go的内存分配基于TCMalloc的原理实现。通常我们说内存管理指的是堆（Heap）内存管理，因为栈（Stack）不需要我们关心。</p><h4 id="关于tcmalloc"><a href="#关于tcmalloc" class="headerlink" title="关于tcmalloc"></a>关于tcmalloc</h4><p>tcmalloc是一个内存管理库，全称Thread-Cache Malloc，理解为带缓存的内存管理，其实就是为每一个线程创建一个缓存，每次为线程分配内存的时候，首先判断其大小，较小的内存块（小于32K）会首先从缓存中获取，较大的才会从Head内存中分配，这样可以减少系统调用，提高效率。</p><h5 id="三个关于tcmalloc的重要概念"><a href="#三个关于tcmalloc的重要概念" class="headerlink" title="三个关于tcmalloc的重要概念"></a>三个关于tcmalloc的重要概念</h5><ul><li><p>ThreadCache：每个线程创建的时候会为其分配包含多个内存块的链表，这些内存块大小相同，你也可以理解为其实链表是对内存块按照大小进行分类。每次申请内存的时候，当申请的内存小于32k的时候，就在ThredCache选择合适的链表，然后在链表上选择空闲的内存块分配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 为线程分配ThreadCache的时候，进行一次系统调用，后续从ThreadCache上面分配内存的时候不再需要系统调用过程，极大提高了效率。</span><br><span class="line">- ThreadChahe是线程安全的，因为它为某个线程所独有，不会产生竞争。</span><br></pre></td></tr></table></figure></li><li><p>CentralCache：粗暴翻译就是”中央缓存”，其实是有点那个意思。它是进程级别的，同一进程所有线程共享。CentralCache本质上也是由空闲内存块组成的链表，当ThreadCache上空闲内存块不足的时候，CentralCache会分配给它一些；当ThredCache上面空闲的内存块过多的时，会将自身的空闲内存块返还给CentralCache。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- CentralCache是同一进程的线程共享的，所以会产生竞争，操作的时候需要添加锁。</span><br></pre></td></tr></table></figure></li><li><p>PageHead：其实是堆内存的抽象，也是由若干链表组成，每个链表包含多个Span，每个Span其实使用多个Page组成。当CentralCache不足的时候，会从PageHead中获取，PageHead会将Span分成若干个内存块，放到CentralCache中。当CentralCache空闲内存太多时，会将一部分返还给PageHeap。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- PageHeap会产生多个CentralCache竞争，所以也是需要添加锁。</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2020/08/16/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-202008122256022581597244742123.png" alt></p><h5 id="TCMalloc内存分配"><a href="#TCMalloc内存分配" class="headerlink" title="TCMalloc内存分配"></a>TCMalloc内存分配</h5><ul><li>小对象直接从ThredCache中分配。</li><li>中等对象从PageHead中选择合适数量的Span进行分配。</li><li>大对象则从lagre span set分配。</li></ul><hr><h4 id="GO的内存管理"><a href="#GO的内存管理" class="headerlink" title="GO的内存管理"></a>GO的内存管理</h4><p><img src="/2020/08/16/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/38720_10.png" alt></p><p>GO内存管理原理是基于TCMalloc基础，GO内存管理中与之对应的三个重要组成部分包括：</p><h5 id="MHeap"><a href="#MHeap" class="headerlink" title="MHeap"></a>MHeap</h5><p>对内存的抽象依照Span Class对Span进行归类，形成树形结构。当需要分配的内存大于32K就在Mheap上面分配，首先根据申请内存的大小size得到Class szie, 进而根据Class size得到Span class, 最后根据Span class得到内存快Span。</p><h4 id="MCache"><a href="#MCache" class="headerlink" title="MCache"></a>MCache</h4><p>与TCMalloc对应的ThreadCache, 但是与ThredCache与线程绑定不同，Mcache是与逻辑处理器P绑定，因为每一个Goroutine是运行在Processor，当需要申请的内存小于32K的时候，直接从MCache中得到，而不用进过系统调用，也不与其他Goroutine产生竞争。</p><h4 id="MCentral"><a href="#MCentral" class="headerlink" title="MCentral"></a>MCentral</h4><p>与TCMalloc对应的CentralCache,作用也类似，不再赘述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;GO内存管理&quot;&gt;&lt;a href=&quot;#GO内存管理&quot; class=&quot;headerlink&quot; title=&quot;GO内存管理&quot;&gt;&lt;/a&gt;GO内存管理&lt;/h3&gt;&lt;h4 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;W
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>现代语言的内存管理模型</title>
    <link href="http://www.zhangfuguan.top/2020/08/11/%E7%8E%B0%E4%BB%A3%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.zhangfuguan.top/2020/08/11/现代语言的内存管理模型/</id>
    <published>2020-08-10T16:04:31.000Z</published>
    <updated>2021-04-04T13:17:14.798Z</updated>
    
    <content type="html"><![CDATA[<h3 id="揭开现代语言内存管理的神秘面纱"><a href="#揭开现代语言内存管理的神秘面纱" class="headerlink" title="揭开现代语言内存管理的神秘面纱"></a>揭开现代语言内存管理的神秘面纱</h3><p>–译自：<a href="https://deepu.tech/memory-management-in-programming/">Deepu K Sasidharan</a>，如果你对<a href="https://www.deepu.tech/">Deepu K Sasidharan</a>的内容感兴趣可以在<a href="https://twitter.com/deepu105">twitter</a>上面关注他，随时获取最新动态。</p><h4 id="Part1-什么是内存管理？"><a href="#Part1-什么是内存管理？" class="headerlink" title="Part1 什么是内存管理？"></a>Part1 什么是内存管理？</h4><p>其实内存管理就是控制和协调应用程序访问计算机内存的过程。这是一个严肃的话题，令人困惑，因为对于很多人而言它是一个黑盒子，让人捉摸不透。</p><h4 id="What-is-it"><a href="#What-is-it" class="headerlink" title="What is it ?"></a>What is it ?</h4><p>当我们的程序运行在目标计算机上面的时候，它会通过计算机的内存（RAM）完成以下操作：</p><ul><li>加载需要执行的代码的字节数据</li><li>保存执行时会使用到的数据和结构</li><li>加载代码执行时所需要的所有运行时系统（简而言之，指的是已编译好的程序在运行时所需要的支持系统）</li></ul><p>我们的程序除了使用内存空间保存代码的字节码之外，还会使用到内存中的堆（Heap）和栈（Stack）。</p><h4 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h4><p>栈通常用于静态内存空间的申请，见名知意，它遵循先进后出的规则。</p><ul><li>由于栈FIFO的特性，存储和查找数据从栈顶开始，无需查找对比，所以速度非常快</li><li>栈是一块连续的内存区域，其地址的增长方向是向下进行的，向内存地址减小的方向增长。保存在栈上面的数据是静态并且有限的（数据的大小在编译的时候已经确定）。</li><li>与函数调用相关的数据将会以栈帧（<strong>stack frames</strong>）的形式保存，每个栈帧其实就是函数执行的环境，比如说函数每次申请一个新的变量，会将其push到栈的最顶层的块中，当函数退出的时候变量也随之销毁。</li><li>对于那些支持多线程的应用，系统将会为每一个线程创建一个栈，数据为每个线程所独有。</li><li>栈的内存管理简单明了，即由OS（系统）来完成。</li><li>保存在栈中典型的数据包括局部变量，指针和函数块。</li><li>相对于堆（Heap）而言，由于栈的大小收到限制，所以会有栈溢出的错误。</li><li>对于绝大多数的语言来说报错在栈上面的数据会有大小的限制。</li></ul><p><img src="https://i.imgur.com/7KpvEn1.gif" alt="stack in JavaScript"></p><p>JavaScript中使用的堆栈，对象存储在Heap中，并在需要时引用。</p><h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><p>不同于栈，堆通常用于动态分配内存，在堆中程序需要使用指针来查找数据。</p><ul><li>在查找数据方面堆的效率比栈慢很多，但是可存储的数据量更大。</li><li>可以将动态大小的数据存储在堆中。</li><li>同一个应用（可以理解为进程）的不同线程可以共享堆中的数据。</li><li>由于堆内存是动态的，是语言自己申请和回收，所以堆内存的管理相对棘手。</li><li>通常堆中会保存全局变量，对象，映射等负载数据结构。</li><li>当你使用的堆内存容量超过你申请的内存容量时会抛出内存溢出的错误（当然也会有其他因素导致，比如GC）。</li><li>通常而言，对于堆内存所能保存的数据容量是没有限制的，当然，它会受限于你应用所能申请的最大内存容量。</li></ul><h4 id="Why-is-it-important"><a href="#Why-is-it-important" class="headerlink" title="Why is it important?"></a>Why is it important?</h4><p>不同于硬盘，内存的容量不可能是不受限制的扩张，如果一个应用持续申请内存而不回收，那么最终将会把内存消耗殆尽，进而使系统崩溃。因此程序不能随心所欲的占用内存，这就要求程序开发者能够解决这个问题，而目前大多数语言都提供了解决这个问题的方法和途径。我们讨论的内存管理大多数情况下指的是堆的内存管理。</p><h4 id="管理内存的方法"><a href="#管理内存的方法" class="headerlink" title="管理内存的方法"></a>管理内存的方法</h4><p>语言不会默认帮你管理内存，需要你手动申请和释放对象所需要的内存。比如，C和C++，他们提供了 <code>malloc</code>, <code>realloc</code>, <code>calloc</code>方法来申请内存，提供<code>free</code>方法来释放内存空间。这些都可以帮助开发者有效的管理堆内存，并且使用指针也是有效管理堆内存的一种方法，因人而异。</p><h4 id="垃圾回收（GC）"><a href="#垃圾回收（GC）" class="headerlink" title="垃圾回收（GC）"></a>垃圾回收（GC）</h4><p>通过释放未使用的内存分配来自动管理堆内存。GC普遍用于现代语言的内存管理当中。GC会间歇式运行，因此可能会导致较小的开销，称为暂停时间。目前<strong>JVM(Java/Scala/Groovy/Kotlin)</strong>, <strong>JavaScript</strong>, <strong>C#</strong>, <strong>Golang</strong>, <strong>OCaml</strong> 和 <strong>Ruby</strong> 这些语言也使用GC作为默认的内存管理方式。</p><p><img src="https://i.imgur.com/AZaR0LP.gif" alt="Mark &amp; sweep GC"></p><p>常见垃圾回收机制</p><h5 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h5><p>也称之为 <strong>Tracing GC</strong> 。它是典型的两阶段算法，首先将被引用的对象标记为“存活”，然后将处于非“存活”状态的对象销毁。<strong>JVM</strong>, <strong>C#</strong>, <strong>Ruby</strong>, <strong>JavaScript</strong>, 和<strong>Golang</strong> 都是采用这种方法。与<strong>JVM</strong>不同的是，<strong>JavaScript</strong>的V8引擎则是采用引用计数和标记清除相结合的方法实现其内存管理。这种GC方式也可以作为外部的库应用到C和C++上面。</p><h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><p>在这种方法中，每个对象在创建之初都会得到一个引用计数，当这个对象被引用时计数会加一，当删除该引用时会减一，当引用计数为0的时候，该对象就会被删除释放。引用计数并非一种非常理想的解决方法，因为它无法处理循环引用。</p><h4 id="RAII（Resource-Acquisition-is-Initialization）"><a href="#RAII（Resource-Acquisition-is-Initialization）" class="headerlink" title="RAII（Resource Acquisition is Initialization）"></a>RAII（Resource Acquisition is Initialization）</h4><p>在这种内存管理中，对象的内存分配伴随着对象从创建到销毁的整个生命周期。RAII技术被认为是C++中内存管理的最佳方法，也被<strong>Ada</strong> 和<strong>Rust</strong>所采用。</p><h4 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h4><p>它类似于引用计数，但是与引用计数间歇式运行不同，它是在程序编译的时候将保存和释放的指令插入到代码当中，并且当引用计数为0的时候自动清除释放，这个过程不会造成任何程序暂停。但是它也不能处理循环引用并且依赖于开发者使用特定的关键指令来处理。在<strong>Objective C</strong> &amp; <strong>Swift</strong>中采用这种方式。</p><h4 id="Ownership"><a href="#Ownership" class="headerlink" title="Ownership"></a>Ownership</h4><p>它结合了RAII和所有权模型，任何值都必须具有一个变量作为其所有者（一次只有一个所有者），当所有者超出范围时，该值将被释放以释放内存，而不管它在栈或堆内存中。它与编译时有点类似，被应用于<strong>Rust</strong>语言中，我目前还没发现其他语言使用这种方式。</p><p><img src="https://thepracticaldev.s3.amazonaws.com/i/cxs080wnnykflkmsfo9p.png" alt="Ownership in Rust"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;揭开现代语言内存管理的神秘面纱&quot;&gt;&lt;a href=&quot;#揭开现代语言内存管理的神秘面纱&quot; class=&quot;headerlink&quot; title=&quot;揭开现代语言内存管理的神秘面纱&quot;&gt;&lt;/a&gt;揭开现代语言内存管理的神秘面纱&lt;/h3&gt;&lt;p&gt;–译自：&lt;a href=&quot;https
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="系统" scheme="http://www.zhangfuguan.top/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://www.zhangfuguan.top/2020/07/15/%E9%97%AD%E5%8C%85/"/>
    <id>http://www.zhangfuguan.top/2020/07/15/闭包/</id>
    <published>2020-07-14T16:37:40.000Z</published>
    <updated>2021-04-04T13:17:14.798Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初识闭包"><a href="#初识闭包" class="headerlink" title="初识闭包"></a>初识闭包</h3><p>闭包是一种能访问当前作用域外变量的函数。</p><p>简单来说就是：使用某个函数时，依赖于该函数作用域外的环境，该函数称之为闭包。</p><p><strong>判断一下情况是否是闭包？</strong></p><ul><li><p>A</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;Jane&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;My name is &quot;</span>, name)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>B</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;Jane&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;My name is &quot;</span>, name)</span><br><span class="line">&#125;(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;Jane&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;My name is Maria&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;this is &quot;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>A </strong> 是标准的闭包，闭包是用了当前函数作用域外的变量name</p><p><strong>B</strong> 不是闭包，函数内的name是自己作用域的变量，是通过参数传递进来的</p><p><strong>C</strong> 不是闭包，没有是用作用域外的环境，外部环境对其没用影响</p><h3 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h3><p><strong>判断一下程序运行的结果</strong></p><ul><li><p>A</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fac := fA(<span class="number">10</span>)</span><br><span class="line">fac()</span><br><span class="line">fac()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fA</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Println(<span class="string">&quot;i:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>B</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fbc := fB(<span class="number">10</span>)</span><br><span class="line">fbc()</span><br><span class="line">fbc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fB</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;i:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>A的结果：<br>11<br>12</p><p>B的结果：</p><p>11<br>11</p><p>A：闭包引用了外部环境的变量，也就是说共享了一个栈上面的变量，致使该变量不会立刻被销毁，延长了改变变量的生命周期。闭包对变量追加了操作，所以会累加。</p></blockquote><h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><ul><li>访问其他函数内的变量</li><li>延长变量的生命周期，保护其不备回收机制回收</li><li>避免全局变量被污染 方便调用上下文的局部变量 加强封装性。更为了高内聚、低耦合的设计思想，使用闭包可以提升开发效率，更便于维护。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;初识闭包&quot;&gt;&lt;a href=&quot;#初识闭包&quot; class=&quot;headerlink&quot; title=&quot;初识闭包&quot;&gt;&lt;/a&gt;初识闭包&lt;/h3&gt;&lt;p&gt;闭包是一种能访问当前作用域外变量的函数。&lt;/p&gt;
&lt;p&gt;简单来说就是：使用某个函数时，依赖于该函数作用域外的环境，该函数称之
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go单例模式</title>
    <link href="http://www.zhangfuguan.top/2020/07/07/go%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhangfuguan.top/2020/07/07/go单例模式/</id>
    <published>2020-07-06T16:37:26.000Z</published>
    <updated>2021-04-04T13:17:14.786Z</updated>
    
    <content type="html"><![CDATA[<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>go最大的优势之一在于在语言层面通过goroutine实现了并发编程，提高了执行效率；但是并发随之带来的事就如何保证线程安全。通过我们会使用单例模式来保证线程安全，即在程序中我们只需要某个“类”实例化一次即可，保证一个“类“仅有一个实例，并提供一个获取实例的方法。</p><h4 id="小刀初试"><a href="#小刀初试" class="headerlink" title="小刀初试"></a>小刀初试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instance ...</span></span><br><span class="line"><span class="keyword">type</span> Instance <span class="keyword">struct</span> &#123;</span><br><span class="line">Time <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Instance</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span> *<span class="title">Instance</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">instance = &amp;Instance&#123;</span><br><span class="line">Time: time.Now().Unix(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在高并发情况下无法保证其线程的安全性。</p><h4 id="简单的锁"><a href="#简单的锁" class="headerlink" title="简单的锁"></a>简单的锁</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instance ...</span></span><br><span class="line"><span class="keyword">type</span> Instance <span class="keyword">struct</span> &#123;</span><br><span class="line">Time <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Instance</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span> *<span class="title">Instance</span></span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">instance = &amp;Instance&#123;</span><br><span class="line">Time: time.Now().Unix(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时是可以解决并发线程安全的问题，但是每次获取实例的时候都需要经过加锁解锁的过程，造成性能不必要的损耗。</p><h4 id="再进一步"><a href="#再进一步" class="headerlink" title="再进一步"></a>再进一步</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instance ...</span></span><br><span class="line"><span class="keyword">type</span> Instance <span class="keyword">struct</span> &#123;</span><br><span class="line">Time <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Instance</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span> *<span class="title">Instance</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">instance = &amp;Instance&#123;</span><br><span class="line">Time: time.Now().Unix(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是有在创建的时候才需要添加锁，避免不必要的锁。</p><h4 id="首选Sync-Atomic"><a href="#首选Sync-Atomic" class="headerlink" title="首选Sync.Atomic"></a>首选Sync.Atomic</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instance ...</span></span><br><span class="line"><span class="keyword">type</span> Instance <span class="keyword">struct</span> &#123;</span><br><span class="line">Time <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Instance</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span> *<span class="title">Instance</span></span> &#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">instance = &amp;Instance&#123;</span><br><span class="line">Time: time.Now().Unix(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题外话：Sync-Once原理"><a href="#题外话：Sync-Once原理" class="headerlink" title="题外话：Sync.Once原理"></a>题外话：Sync.Once原理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Once is an object that will perform exactly one action.</span></span><br><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// done indicates whether the action has been performed.</span></span><br><span class="line"><span class="comment">// It is first in the struct because it is used in the hot path.</span></span><br><span class="line"><span class="comment">// The hot path is inlined at every call site.</span></span><br><span class="line"><span class="comment">// Placing done first allows more compact instructions on some architectures (amd64/x86),</span></span><br><span class="line"><span class="comment">// and fewer instructions (to calculate offset) on other architectures.</span></span><br><span class="line">done <span class="keyword">uint32</span></span><br><span class="line">m    Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123; <span class="comment">// check</span></span><br><span class="line"><span class="comment">// Outlined slow-path to allow inlining of the fast-path.</span></span><br><span class="line">o.doSlow(f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">doSlow</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">o.m.Lock()                          <span class="comment">// lock</span></span><br><span class="line"><span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> o.done == <span class="number">0</span> &#123;                    <span class="comment">// check</span></span><br><span class="line"><span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用互斥锁实现原子操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h4&gt;&lt;p&gt;go最大的优势之一在于在语言层面通过goroutine实现了并发编程，提高了执行效率；但是并发随之带来的事就如何保证线程安全
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="channel" scheme="http://www.zhangfuguan.top/tags/channel/"/>
    
      <category term="设计模式" scheme="http://www.zhangfuguan.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>go-channel</title>
    <link href="http://www.zhangfuguan.top/2020/06/14/go-channel/"/>
    <id>http://www.zhangfuguan.top/2020/06/14/go-channel/</id>
    <published>2020-06-14T15:44:27.000Z</published>
    <updated>2021-04-04T13:17:14.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Golang中channel总结"><a href="#Golang中channel总结" class="headerlink" title="Golang中channel总结"></a>Golang中channel总结</h3><hr><p>golang里面倡导的是“通过通信来共享内存”，简单来说channel是groutine之间通信的桥梁。</p><h4 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h4><ul><li>声明</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无缓冲channel</span></span><br><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> DataType)</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> DataType</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有缓冲channel</span></span><br><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> DataType, n)</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> DataType</span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> DataType, n)</span><br></pre></td></tr></table></figure><ul><li>发送与接收</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D; make(chan int)</span><br><span class="line">&#x2F;&#x2F; 发送</span><br><span class="line">ch &lt;- 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接收</span><br><span class="line">n :&#x3D; &lt;- ch</span><br></pre></td></tr></table></figure><ul><li><p>注意：channel是goroutine之间通信的机制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：<code>fatal error: all goroutines are asleep - deadlock!</code></p><p>channel是不同goroutine之间通信的机制，同一个goroutine里面发送和接收是会造成阻塞的。修改如下就没问题了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ch :&#x3D; make(chan int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">ch &lt;- 1</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-无缓冲channel与有缓冲channel"><a href="#2-无缓冲channel与有缓冲channel" class="headerlink" title="2. 无缓冲channel与有缓冲channel"></a>2. 无缓冲channel与有缓冲channel</h4><h5 id="2-1-关于阻塞"><a href="#2-1-关于阻塞" class="headerlink" title="2.1 关于阻塞"></a>2.1 关于阻塞</h5><ul><li>无缓冲channel的发送和接收是同步的</li><li>无缓冲channel的接收在发送之前阻塞</li><li>在已经包含数据的无缓冲channel的发送在接收之前阻塞</li><li>有缓冲channel的发送和接收可以是异步的</li><li>当有缓冲channel队列满了时，发送阻塞</li><li>当有缓冲channel为空时，接收阻塞</li></ul><h5 id="2-2-关闭之后操作"><a href="#2-2-关闭之后操作" class="headerlink" title="2.2 关闭之后操作"></a>2.2 关闭之后操作</h5><ul><li><p>重复关闭 channel 会导致 panic。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: close of closed channel</span><br></pre></td></tr></table></figure></li><li><p>向关闭的 channel 发送数据会 panic。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: send on closed channel</span><br></pre></td></tr></table></figure></li><li><p>从关闭的 channel 读数据不会 panic，读出 channel 中已有的数据之后再读就是 channel 类似的默认值，比如 chan int 类型的 channel 关闭之后读取到的值为 0。</p></li></ul><h4 id="3-channel死锁的几种常见情况"><a href="#3-channel死锁的几种常见情况" class="headerlink" title="3. channel死锁的几种常见情况"></a>3. channel死锁的几种常见情况</h4><ul><li><p>同一个goroutine中对同一个channel进行读写操作（上面已经提到）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在两个以上的goroutine中，channel的读写早于goroutine的创建。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch &lt;- <span class="number">12</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多个goroutine使用多个channel进行通信，channel之前互相等待对方状态造成死锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ch1 :&#x3D; make(chan int)</span><br><span class="line">ch2 :&#x3D; make(chan int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-ch1:</span><br><span class="line">ch2 &lt;- 2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-ch2:</span><br><span class="line">ch1 &lt;- 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-channel常见用法"><a href="#3-channel常见用法" class="headerlink" title="3. channel常见用法"></a>3. channel常见用法</h4><h5 id="3-1-通信"><a href="#3-1-通信" class="headerlink" title="3.1 通信"></a>3.1 通信</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-range遍历"><a href="#3-2-range遍历" class="headerlink" title="3.2  range遍历"></a>3.2  range遍历</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ch :&#x3D; make(chan int, 3)</span><br><span class="line">go func() &#123;</span><br><span class="line">for i :&#x3D; 1; i &lt; 4; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(ch)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">for c :&#x3D; range ch &#123;</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range c</code>产生的迭代值为Channel中发送的值，它会一直迭代直到channel被关闭。上面的例子中如果把<code>close(c)</code>注释掉，程序会一直阻塞在<code>for …… range</code>那一行。</p><h5 id="3-3-超时处理"><a href="#3-3-超时处理" class="headerlink" title="3.3 超时处理"></a>3.3 超时处理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ch :&#x3D; make(chan int)</span><br><span class="line">go func() &#123;</span><br><span class="line">time.Sleep(time.Second * 6)</span><br><span class="line">ch &lt;- 99</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case re :&#x3D; &lt;-ch:</span><br><span class="line">fmt.Println(&quot;ch: &quot;, re)</span><br><span class="line">case &lt;-time.After(time.Second * 5):</span><br><span class="line">fmt.Println(&quot;timeout&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用time.After()返回一个类型为<code>&lt;-chan Time</code>的单向的channel。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Golang中channel总结&quot;&gt;&lt;a href=&quot;#Golang中channel总结&quot; class=&quot;headerlink&quot; title=&quot;Golang中channel总结&quot;&gt;&lt;/a&gt;Golang中channel总结&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;golang里面倡
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="channel" scheme="http://www.zhangfuguan.top/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>常见网络知识总结</title>
    <link href="http://www.zhangfuguan.top/2020/06/14/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://www.zhangfuguan.top/2020/06/14/常见网络知识总结/</id>
    <published>2020-06-13T16:08:12.000Z</published>
    <updated>2021-04-04T13:17:14.795Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-osi模型与五层架构模型"><a href="#1-osi模型与五层架构模型" class="headerlink" title="1.osi模型与五层架构模型"></a>1.osi模型与五层架构模型</h4><p><img src="/2020/06/14/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/2020-06-14-00-36-07.png" alt="常见网络知识总结"></p><h4 id="2-五层架构模型中各层对应的网络协议"><a href="#2-五层架构模型中各层对应的网络协议" class="headerlink" title="2.五层架构模型中各层对应的网络协议"></a>2.五层架构模型中各层对应的网络协议</h4><table><thead><tr><th>层</th><th>协议</th></tr></thead><tbody><tr><td>应用层</td><td>HTTP，SMTP</td></tr><tr><td>传输层</td><td>TCP, UPD</td></tr><tr><td>网络层</td><td>IP, ICMP</td></tr><tr><td>数据链路层</td><td>PPP</td></tr><tr><td>物理层</td><td>IEEE802.3</td></tr></tbody></table><h4 id="3-TCP三次握手和四次握手"><a href="#3-TCP三次握手和四次握手" class="headerlink" title="3.TCP三次握手和四次握手"></a>3.TCP三次握手和四次握手</h4><h5 id="三次握手（建立连接）"><a href="#三次握手（建立连接）" class="headerlink" title="三次握手（建立连接）"></a>三次握手（建立连接）</h5><blockquote><p>TCP是一种面向连接的协议，在发送数据之前，双方必须建立一条可信任的连接。<br><img src="/2020/06/14/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/2020-06-14-00-09-56.png" alt="常见网络知识总结"></p><ol><li>第一次：Client发送一个包含标志位SYN=1, Seq=随机数J的数据包给Server。Client处于SYN_SENT状态。</li><li>第二次：Server检查SYN=1之后知道Client想建立连接，发送一个包含SYN=1, ACK=1， ACKnum=J+1，Seq=随机数K的数据包给Client。Server处于SYN_RCVD状态。</li><li>第三次：Client检查SYN=1,ACK=1,ACKnum=J+1之后，发送ACKnum=K+1给Server,Server检查ACKnum=k+1之后连接建立。Client和Server均处于established的状态。<br><img src="/2020/06/14/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/2020-06-14-00-10-56.png" alt="常见网络知识总结"></li></ol></blockquote><blockquote><p>ACK: 确认连接成功标志位，ACKnum确认数据以及发送完成标志位。</p></blockquote><h4 id="四次握手（断开连接）"><a href="#四次握手（断开连接）" class="headerlink" title="四次握手（断开连接）"></a>四次握手（断开连接）</h4><blockquote><p>TCP是全双工通信，双方可以互相发送数据。所以需要两次确认。<br><img src="/2020/06/14/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/2020-06-14-00-11-52.png" alt="常见网络知识总结"></p><ol><li>第一次挥手：Client发送一个FIN，<strong>用来关闭Client到Server的数据传送</strong>，Client进入FIN_WAIT_1状态。</li><li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</li><li>第三次挥手：Server发送一个FIN，<strong>用来关闭Server到Client的数据传送</strong>，Server进入LAST_ACK状态。</li><li>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</li></ol></blockquote><h4 id="3-三次握手可以换成两次吗"><a href="#3-三次握手可以换成两次吗" class="headerlink" title="3. 三次握手可以换成两次吗"></a>3. 三次握手可以换成两次吗</h4><p>不行，三次握手可以防止向已失效的连接返送请求。<br><a href="https://juejin.im/post/5daf0e576fb9a04e3348d97b#heading-1">网络知识点</a></p><h4 id="4-为什么断开要四次握手"><a href="#4-为什么断开要四次握手" class="headerlink" title="4. 为什么断开要四次握手"></a>4. 为什么断开要四次握手</h4><p>TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当 A 向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能够接受到来自 B 发出的数据；B 向 A 发出 ACK 报文段也只是告诉 A ，它自己知道 A 没有数据要发了，但 B 还是能够向 A 发送数据。</p><h4 id="5-浏览器中点击“www-baidu-com-quot-之后发生什么"><a href="#5-浏览器中点击“www-baidu-com-quot-之后发生什么" class="headerlink" title="5.浏览器中点击“www.baidu.com&quot;之后发生什么"></a>5.浏览器中点击“<a href="http://www.baidu.com&quot;之后发生什么">www.baidu.com&quot;之后发生什么</a></h4><ol><li>由域名→IP地址 寻找IP地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器。（DNS域名解析）</li><li>建立TCP/IP连接（三次握手具体过程）</li><li>由浏览器发送一个HTTP请求</li><li>经过路由器的转发，通过服务器的防火墙，该HTTP请求到达了服务器</li><li>服务器处理该HTTP请求，返回一个HTML文件</li><li>浏览器解析该HTML文件，并且显示在浏览器端</li><li>断开连接四次握手</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-osi模型与五层架构模型&quot;&gt;&lt;a href=&quot;#1-osi模型与五层架构模型&quot; class=&quot;headerlink&quot; title=&quot;1.osi模型与五层架构模型&quot;&gt;&lt;/a&gt;1.osi模型与五层架构模型&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2020/06/14/
      
    
    </summary>
    
    
      <category term="网络" scheme="http://www.zhangfuguan.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Docker环境实现基于keepalived双主高可用MySQL</title>
    <link href="http://www.zhangfuguan.top/2019/05/12/Docker%E7%8E%AF%E5%A2%83%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8Ekeepalived%E5%8F%8C%E4%B8%BB%E9%AB%98%E5%8F%AF%E7%94%A8MySQL/"/>
    <id>http://www.zhangfuguan.top/2019/05/12/Docker环境实现基于keepalived双主高可用MySQL/</id>
    <published>2019-05-12T14:49:59.000Z</published>
    <updated>2021-04-04T13:17:14.783Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在公司(博主在一家云计算公司工作)主要做MySQL数据库产品，说白了就是给用户提供一个高可用的MySQL数据库， 我们为用户提供了一个具备服务高可用，数据一致性的运维平台。 在方案的选择中我们最开始想到的是[利用Keepalived构建高可用MySQL双主自动切换，但是数据同步只能选择双主半同步，无法保证数据的强一致性，参考率市场上常见的方案之后，任务pxc是目前最符合我们要求的选项。<br><img src="/2019/05/12/Docker%E7%8E%AF%E5%A2%83%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8Ekeepalived%E5%8F%8C%E4%B8%BB%E9%AB%98%E5%8F%AF%E7%94%A8MySQL/2020-06-14-00-57-19.png" alt="Docker环境实现基于keepalived双主高可用MySQL"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;最近在公司(博主在一家云计算公司工作)主要做MySQL数据库产品，说白了就是给用户提供一个高可用的MySQL数据库， 我们为用户提供了一个具
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.zhangfuguan.top/tags/MySQL/"/>
    
      <category term="数据库， 高可用" scheme="http://www.zhangfuguan.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C-%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装配置LNMP环境</title>
    <link href="http://www.zhangfuguan.top/2019/05/11/Docker%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AELNMP%E7%8E%AF%E5%A2%83/"/>
    <id>http://www.zhangfuguan.top/2019/05/11/Docker安装配置LNMP环境/</id>
    <published>2019-05-11T13:16:16.000Z</published>
    <updated>2021-04-04T13:17:14.783Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近准备自己写一点东西，但是进场因为线上环境和本地开发环境不一致，弄得晕头转向。所以在windows里面部署vm虚拟机，在虚拟机中运行ubuntu16.04环境，然后起docker,在docker中运行lnmp集成环境。避免麻烦其实我是使用的github上大牛已经集成好的docker-compose 项目，一键执行就可以。<br>项目地址：<a href="https://github.com/yeszao/dnmp">https://github.com/yeszao/dnmp</a></p><h4 id="首先你需要你的虚拟机环境能够连上外网"><a href="#首先你需要你的虚拟机环境能够连上外网" class="headerlink" title="首先你需要你的虚拟机环境能够连上外网"></a>首先你需要你的虚拟机环境能够连上外网</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping baidu.com</span><br></pre></td></tr></table></figure><h4 id="能够连上网络后你需要安装费docker，docker-compose，git"><a href="#能够连上网络后你需要安装费docker，docker-compose，git" class="headerlink" title="能够连上网络后你需要安装费docker，docker-compose，git"></a>能够连上网络后你需要安装费docker，docker-compose，git</h4><blockquote><p>安装docker的教程请查看我的上一篇文章<a href="http://www.zhangfuguan.top/elementary-os-ubuntu16-04-xia-an-zhuang-docker/">http://www.zhangfuguan.top/elementary-os-ubuntu16-04-xia-an-zhuang-docker/</a><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo aot-get install docker-compose</span><br><span class="line">sudo aot-get install git</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="将dnmp项目克隆到本地"><a href="#将dnmp项目克隆到本地" class="headerlink" title="将dnmp项目克隆到本地"></a>将dnmp项目克隆到本地</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;yeszao&#x2F;dnmp.git</span><br></pre></td></tr></table></figure><h4 id="进入dnmp启动即可"><a href="#进入dnmp启动即可" class="headerlink" title="进入dnmp启动即可"></a>进入dnmp启动即可</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd dnmp</span><br><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><h4 id="查看环境是否安装成功"><a href="#查看环境是否安装成功" class="headerlink" title="查看环境是否安装成功"></a>查看环境是否安装成功</h4><ul><li>在虚拟机中访问: <a href="http://localhost//">http://localhost//</a></li><li>在虚拟机中访问: <a href="http://localhost:8080/">http://localhost:8080/</a> (mysql默认账号：root，密码：123456)</li></ul><h4 id="查看虚拟机和docker的ip"><a href="#查看虚拟机和docker的ip" class="headerlink" title="查看虚拟机和docker的ip"></a>查看虚拟机和docker的ip</h4><ul><li>执行ifconfig    </li><li>docker0 便是docker的ip， 而ens33便是虚拟机的ip</li></ul><h4 id="将宿主机与docker内网网络互通"><a href="#将宿主机与docker内网网络互通" class="headerlink" title="将宿主机与docker内网网络互通"></a>将宿主机与docker内网网络互通</h4><ul><li>以管理员身份运行cmd.执行以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROUTE -p add 172.17.0.0 mask 255.255.0.0 192.168.209.155</span><br></pre></td></tr></table></figure></li><li>在windows宿主机浏览器中输入<a href="http://172.17.0.1即可访问">http://172.17.0.1即可访问</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近准备自己写一点东西，但是进场因为线上环境和本地开发环境不一致，弄得晕头转向。所以在windows里面部署vm虚拟机，在虚拟机中运行ubuntu16.04环境，然后起docker,在docker中运行lnmp集成环境。避免麻烦其实我是使用的gith
      
    
    </summary>
    
    
      <category term="容器" scheme="http://www.zhangfuguan.top/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="虚拟化技术" scheme="http://www.zhangfuguan.top/tags/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.zhangfuguan.top/2019/05/07/hello-world/"/>
    <id>http://www.zhangfuguan.top/2019/05/07/hello-world/</id>
    <published>2019-05-06T16:37:26.000Z</published>
    <updated>2021-04-04T13:29:48.919Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for
      
    
    </summary>
    
    
  </entry>
  
</feed>
