<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张副官</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zhangfuguan.top/"/>
  <updated>2023-06-15T16:11:21.056Z</updated>
  <id>http://www.zhangfuguan.top/</id>
  
  <author>
    <name>张副官</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>n数之和</title>
    <link href="http://www.zhangfuguan.top/2023/06/15/n%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://www.zhangfuguan.top/2023/06/15/n数之和/</id>
    <published>2023-06-15T15:08:13.000Z</published>
    <updated>2023-06-15T16:11:21.056Z</updated>
    
    <content type="html"><![CDATA[<h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><p><a href="https://www.bilibili.com/video/BV1bP411c7oJ/?vd_source=2cb3c639254a66c279203f3687b0bee9">两数之和 三数之和【基础算法精讲 02】_哔哩哔哩_bilibili</a><br><a href="https://labuladong.github.io/algo/di-ling-zh-bfe1b/yi-ge-fang-894da/">一个方法团灭 nSum 问题 :: labuladong的算法小抄</a></p><h3 id><a href="#" class="headerlink" title></a></h3><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><p><a href="https://leetcode.cn/problems/two-sum/">力扣-1-两数之和</a></p><h5 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    numsMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> index, ok := numsMap[target-v]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;index, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        numsMap[v] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="暴力破解双遍历"><a href="#暴力破解双遍历" class="headerlink" title="暴力破解双遍历"></a>暴力破解双遍历</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i+<span class="number">1</span>; j&lt;<span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] == target &#123;</span><br><span class="line">                <span class="keyword">return</span> []<span class="type">int</span>&#123;i, j&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p><a href="https://leetcode.cn/problems/3sum/">力扣-15-三数之和</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="comment">// 保存结果</span></span><br><span class="line">    res := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 数组长度</span></span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里为什么-2？</span></span><br><span class="line">    <span class="comment">// 因为这是有序数组，如果有复合条件的结果[下表i,j,k]必然是i&lt;j&lt;k， 所以需要给j, k预留位置</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-2</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 首先nums是有序数组</span></span><br><span class="line">        <span class="comment">// 如果某一列中最小的两个数之和加起来都大于0，则说明和其余的数加起来必然大于0</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i]+nums[i<span class="number">-1</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 元素相同，避免重复，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        j := i+<span class="number">1</span> <span class="comment">// 中间位置</span></span><br><span class="line">        k := n<span class="number">-1</span> <span class="comment">// 最大值的位置，即最右边的位置</span></span><br><span class="line">        <span class="keyword">for</span> j &lt; k &#123;</span><br><span class="line">            sum := nums[i]+nums[j]+nums[k]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> sum == <span class="number">0</span> &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, []<span class="type">int</span>&#123;nums[i], nums[j], nums[k]&#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 还需要排除重复的</span></span><br><span class="line">                j++</span><br><span class="line">                <span class="keyword">for</span> j &lt; k &amp;&amp; nums[j]==nums[j<span class="number">-1</span>] &#123;</span><br><span class="line">                    j++</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                k--</span><br><span class="line">                <span class="keyword">for</span> j &lt; k &amp;&amp; nums[k] == nums[k+<span class="number">1</span>] &#123;</span><br><span class="line">                    k--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> sum &lt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 小于0， 则说明中间值太小了，j需要往右边移动</span></span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> sum &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 大于0，则说明中间值太大了，需要将最右边的k往左边移动</span></span><br><span class="line">                k--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p><a href="https://leetcode.cn/problems/4sum/submissions/">力扣-18-四数之和</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其实和三数之和是一个意思，就是先固定第一个数，然后三个数按照三数之和来处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line"></span><br><span class="line">    res := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(nums)<span class="number">-3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>] == nums[i] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> j := i+<span class="number">1</span>; j&lt;<span class="built_in">len</span>(nums)<span class="number">-2</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> j&gt;i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            k := j+<span class="number">1</span></span><br><span class="line">            r := <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> k &lt; r &#123;</span><br><span class="line">                sum := nums[i]+nums[j]+nums[k]+nums[r]</span><br><span class="line">                <span class="keyword">if</span> sum &lt; target &#123;</span><br><span class="line">                    k++</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> sum  &gt; target &#123;</span><br><span class="line">                    r--</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> sum == target &#123;</span><br><span class="line">                    res = <span class="built_in">append</span>(res, []<span class="type">int</span>&#123;nums[i],nums[j],nums[k],nums[r]&#125;)</span><br><span class="line">                    k++</span><br><span class="line">                    <span class="keyword">for</span> k &lt; r &amp;&amp; nums[k]==nums[k<span class="number">-1</span>] &#123;</span><br><span class="line">                        k++    </span><br><span class="line">                    &#125;</span><br><span class="line">                    r--</span><br><span class="line">                     <span class="keyword">for</span> k &lt; r &amp;&amp; nums[r]==nums[r+<span class="number">1</span>] &#123;</span><br><span class="line">                        r--    </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;教程&quot;&gt;&lt;a href=&quot;#教程&quot; class=&quot;headerlink&quot; title=&quot;教程&quot;&gt;&lt;/a&gt;教程&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1bP411c7oJ/?vd_source=2cb3c6
      
    
    </summary>
    
    
      <category term="算法" scheme="http://www.zhangfuguan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针" scheme="http://www.zhangfuguan.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>二叉树深度问题</title>
    <link href="http://www.zhangfuguan.top/2023/06/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
    <id>http://www.zhangfuguan.top/2023/06/13/二叉树深度问题/</id>
    <published>2023-06-13T00:11:10.000Z</published>
    <updated>2023-06-13T00:13:02.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">minDepth := math.MaxInt64</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, depth <span class="type">int</span>)</span></span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, depth <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">depth ++</span><br><span class="line"><span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> depth &lt; minDepth &#123;</span><br><span class="line">minDepth = depth </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(node.Left, depth)</span><br><span class="line">dfs(node.Right, depth)</span><br><span class="line">&#125;</span><br><span class="line">dfs(root, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> minDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大深度"><a href="#最大深度" class="headerlink" title="最大深度"></a>最大深度</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">minDepth := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, depth <span class="type">int</span>)</span></span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, depth <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">depth ++</span><br><span class="line"><span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> depth &gt; minDepth &#123;</span><br><span class="line">minDepth = depth </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(node.Left, depth)</span><br><span class="line">dfs(node.Right, depth)</span><br><span class="line">&#125;</span><br><span class="line">dfs(root, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> minDepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;最小深度&quot;&gt;&lt;a href=&quot;#最小深度&quot; class=&quot;headerlink&quot; title=&quot;最小深度&quot;&gt;&lt;/a&gt;最小深度&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://www.zhangfuguan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://www.zhangfuguan.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="dfs" scheme="http://www.zhangfuguan.top/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>dfs-岛屿问题</title>
    <link href="http://www.zhangfuguan.top/2023/06/11/dfs-%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/"/>
    <id>http://www.zhangfuguan.top/2023/06/11/dfs-岛屿问题/</id>
    <published>2023-06-11T05:03:27.000Z</published>
    <updated>2023-06-11T05:05:49.439Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/number-of-islands/submissions/">力扣-200-岛屿数量</a><br><a href="https://leetcode.cn/problems/max-area-of-island/submissions/">力扣-695-岛屿最大面积</a><br><a href="https://leetcode.cn/problems/number-of-closed-islands/">力扣-1254-封闭岛屿数量</a></p><h4 id="思路讲解"><a href="#思路讲解" class="headerlink" title="思路讲解"></a>思路讲解</h4><p><a href="https://labuladong.github.io/algo/di-san-zha-24031/bao-li-sou-96f79/yi-wen-mia-4f482/">labuladong-一文搞定岛屿问题</a></p><h4 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIslands</span><span class="params">(grid [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(grid[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录总的结果</span></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    m := <span class="built_in">len</span>(grid)</span><br><span class="line">    n := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j&lt;n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> &#123;</span><br><span class="line">                res++</span><br><span class="line">                toWater(grid, i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toWater</span><span class="params">(grid [][]<span class="type">byte</span>, i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">len</span>(grid)</span><br><span class="line">    n := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(grid [][]<span class="type">byte</span>, r, c <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(grid [][]<span class="type">byte</span>, r, c <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= m || c &gt;= n &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经是海水</span></span><br><span class="line">        <span class="keyword">if</span> grid[r][c] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历过的陆地转为海水</span></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line">        dfs(grid, r<span class="number">-1</span>, c)</span><br><span class="line">        dfs(grid, r+<span class="number">1</span>, c)</span><br><span class="line">        dfs(grid, r, c<span class="number">-1</span>)</span><br><span class="line">        dfs(grid, r, c+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(grid, i, j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="岛屿最大面积"><a href="#岛屿最大面积" class="headerlink" title="岛屿最大面积"></a>岛屿最大面积</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxAreaOfIsland</span><span class="params">(grid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m := <span class="built_in">len</span>(grid)</span><br><span class="line">    n := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    maxIsland := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                nowIsland := toWater(grid, i, j)</span><br><span class="line">                <span class="keyword">if</span> nowIsland &gt; maxIsland &#123;</span><br><span class="line">                    maxIsland = nowIsland</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxIsland</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toWater</span><span class="params">(grid [][]<span class="type">int</span>, i, j <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m := <span class="built_in">len</span>(grid)</span><br><span class="line">    n := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(grid [][]<span class="type">int</span>, r, c <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(grid [][]<span class="type">int</span>, r, c <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r&gt;=m || c &gt;= n &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> grid[r][c] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum++</span><br><span class="line">        grid[r][c] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dfs(grid, r<span class="number">-1</span>, c)</span><br><span class="line">        dfs(grid, r+<span class="number">1</span>, c)</span><br><span class="line">        dfs(grid, r, c<span class="number">-1</span>)</span><br><span class="line">        dfs(grid, r, c+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(grid, i, j)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="封闭岛屿数量"><a href="#封闭岛屿数量" class="headerlink" title="封闭岛屿数量"></a>封闭岛屿数量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closedIsland</span><span class="params">(grid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m := <span class="built_in">len</span>(grid)</span><br><span class="line">    n := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把第一行和最后一行的岛屿转为海水</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j&lt;n; j++ &#123;</span><br><span class="line">        toWater(grid, <span class="number">0</span>, j)</span><br><span class="line">        toWater(grid, m<span class="number">-1</span>, j)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把第一列和最后一列转为海水</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;m; i++ &#123;</span><br><span class="line">        toWater(grid, i, <span class="number">0</span>)</span><br><span class="line">        toWater(grid, i, n<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span>; i&lt;m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j&lt;n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">                res++</span><br><span class="line">                toWater(grid,i,j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toWater</span><span class="params">(grid [][]<span class="type">int</span>, i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">len</span>(grid)</span><br><span class="line">    n := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(grid [][]<span class="type">int</span>, r, c <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(grid [][]<span class="type">int</span>, r, c <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;=m || c &gt;=n &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> grid[r][c] == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        dfs(grid, r, c<span class="number">-1</span>)</span><br><span class="line">        dfs(grid, r, c+<span class="number">1</span>)</span><br><span class="line">        dfs(grid, r<span class="number">-1</span>, c)</span><br><span class="line">        dfs(grid, r+<span class="number">1</span>, c)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(grid, i, j)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/number-of-islands/submissions/&quot;&gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://www.zhangfuguan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="dfs" scheme="http://www.zhangfuguan.top/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>双指针-子数字问题</title>
    <link href="http://www.zhangfuguan.top/2023/06/11/%E5%8F%8C%E6%8C%87%E9%92%88-%E5%AD%90%E6%95%B0%E5%AD%97%E9%97%AE%E9%A2%98/"/>
    <id>http://www.zhangfuguan.top/2023/06/11/双指针-子数字问题/</id>
    <published>2023-06-11T04:54:30.000Z</published>
    <updated>2023-06-11T04:58:21.885Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目大纲"><a href="#题目大纲" class="headerlink" title="题目大纲"></a>题目大纲</h4><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/submissions/">力扣-209-长度最小的子数组</a><br><a href="https://leetcode.cn/problems/subarray-product-less-than-k/submissions/">力扣-713-乘积小于K的子数组</a><br><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/">力扣-1004-最大连续1的个数III</a><br><a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/">力扣-1234-替换子串得到平衡串</a><br><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/">力扣-1658-将x减到0的最小操作数</a></p><h4 id="思路讲解"><a href="#思路讲解" class="headerlink" title="思路讲解"></a>思路讲解</h4><p><a href="https://www.bilibili.com/video/BV1hd4y1r7Gq/?vd_source=2cb3c639254a66c279203f3687b0bee9">同向双指针 滑动窗口【基础算法精讲 01】_哔哩哔哩_bilibili</a></p><h4 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubArrayLen</span><span class="params">(target <span class="type">int</span>, nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    minLen := <span class="built_in">len</span>(nums)+<span class="number">1</span> <span class="comment">// 这里保证初始量比最大值还大就行，还有一种方式是直接用math.MaxInt</span></span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right:= <span class="number">0</span>; right &lt; <span class="built_in">len</span>(nums); right++ &#123;</span><br><span class="line">        sum = sum + nums[right]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> sum &gt;= target &#123;</span><br><span class="line">            nowLen := right-left+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nowLen &lt; minLen &#123;</span><br><span class="line">                minLen = nowLen</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动左指针</span></span><br><span class="line">            sum = sum - nums[left]</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> minLen == <span class="built_in">len</span>(nums)+<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="乘积小于k的子数组"><a href="#乘积小于k的子数组" class="headerlink" title="乘积小于k的子数组"></a>乘积小于k的子数组</h4><ul><li>核心点在于：假设左指针为left，右指针为right，则固定right点，所有满足条件的子数组数量为：right-left+1<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> k &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    product := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(nums); right++ &#123;</span><br><span class="line">        product = product * nums[right]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> product &gt;= k &#123;</span><br><span class="line">            product = product/nums[left]</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = res + (right-left+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="无重复字符的最小子串"><a href="#无重复字符的最小子串" class="headerlink" title="无重复字符的最小子串"></a>无重复字符的最小子串</h4><h5 id="使用简单map"><a href="#使用简单map" class="headerlink" title="使用简单map"></a>使用简单map</h5><ul><li>首先使用map保存right遍历过的节点，key为字符对应的字节，value为字节在字符串数组中的位置</li><li>如果没有重复，则当前无重复结果now+1，并且把当前字符加入到map中</li><li>如果有重复，则把left指针移动到重复节点的后面一个，并且需要删除原来left-》重复节点，最后把当前节点计入map<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    strMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    now := <span class="number">0</span></span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right:=<span class="number">0</span>; right &lt; <span class="built_in">len</span>(s); right++ &#123;</span><br><span class="line">        <span class="keyword">if</span> existIndex, ok := strMap[s[right]]; ok &#123;</span><br><span class="line">            <span class="keyword">for</span> left &lt; existIndex+<span class="number">1</span> &#123;</span><br><span class="line">                <span class="built_in">delete</span>(strMap, s[left])</span><br><span class="line">                left++</span><br><span class="line">            &#125;</span><br><span class="line">            left = existIndex+<span class="number">1</span></span><br><span class="line">            strMap[s[right]] = right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            strMap[s[right]] = right</span><br><span class="line">            now = right-left+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> now &gt; max &#123;</span><br><span class="line">                max = now</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/06/11/%E5%8F%8C%E6%8C%87%E9%92%88-%E5%AD%90%E6%95%B0%E5%AD%97%E9%97%AE%E9%A2%98/1.jpg" alt="image.png"></li></ul><p>有更好的做法》》》》》 hhhh, 是我看大佬教程学到的，上面是自己琢磨的。</p><h5 id="使用map计数器"><a href="#使用map计数器" class="headerlink" title="使用map计数器"></a>使用map计数器</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    strCounter := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(s); right++ &#123;</span><br><span class="line">        strCounter[s[right]]++</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> strCounter[s[right]] &gt; <span class="number">1</span> &#123;</span><br><span class="line">            strCounter[s[left]]--</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right-left+<span class="number">1</span> &gt; max &#123;</span><br><span class="line">            max = right-left+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大连续1的个数III"><a href="#最大连续1的个数III" class="headerlink" title="最大连续1的个数III"></a>最大连续1的个数III</h4><p>关键在于Counter的设计</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestOnes</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= k &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    maxLen := <span class="number">0</span></span><br><span class="line">    zeroCounter := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right := <span class="number">0</span>; right &lt; <span class="built_in">len</span>(nums); right++ &#123;</span><br><span class="line">        zeroCounter[nums[right]]++</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[right] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> zeroCounter[nums[right]] &gt; k &#123;</span><br><span class="line">                zeroCounter[nums[left]]--</span><br><span class="line">                left++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right-left+<span class="number">1</span> &gt; maxLen &#123;</span><br><span class="line">            maxLen = right-left+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="替换子串得到平衡串"><a href="#替换子串得到平衡串" class="headerlink" title="替换子串得到平衡串"></a>替换子串得到平衡串</h4><ul><li>假设字符串长度为n</li><li>如果Q&#x2F;W&#x2F;E&#x2F;R的出现次数都等于n&#x2F;4，则说明已经平衡了</li><li>如果除了子串之外的字符Q&#x2F;W&#x2F;E&#x2F;R的出现次数都小于或等于n&#x2F;4，说明可以通过子串的填补来实现平衡；如果大于n&#x2F;4则说明无法通过当前子串来实现平衡（因为你无法改变子串之外的字符，比如QQQ[QWERR]，子串QWERR之外的字符中Q出现了三次大于2，则你无论如何改变子串都无法实现平衡；反之，如果是这样的QQR[QWERR]，则可以将子串改变为[WWERE]&#x3D;&gt;QQRWWERE,便实现了平衡）。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">balancedString</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    counter := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        counter[s[i]]++</span><br><span class="line">    &#125;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    m := <span class="built_in">len</span>(s)/<span class="number">4</span></span><br><span class="line">    min := math.MaxInt <span class="comment">// 其实这个只是定义一个最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果WQER四个字符的个数恰好是m，则说明已经是平衡字符串了</span></span><br><span class="line">    <span class="keyword">if</span> counter[<span class="string">&#x27;Q&#x27;</span>] == m &amp;&amp;</span><br><span class="line">        counter[<span class="string">&#x27;W&#x27;</span>] == m &amp;&amp;</span><br><span class="line">          counter[<span class="string">&#x27;E&#x27;</span>] == m &amp;&amp;</span><br><span class="line">            counter[<span class="string">&#x27;R&#x27;</span>] == m &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right:=<span class="number">0</span>; right&lt;<span class="built_in">len</span>(s); right++ &#123;</span><br><span class="line">        <span class="comment">// 属于子串范围的就应该减去</span></span><br><span class="line">        counter[s[right]]--</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> counter[<span class="string">&#x27;Q&#x27;</span>] &lt;= m &amp;&amp;</span><br><span class="line">                counter[<span class="string">&#x27;W&#x27;</span>] &lt;= m &amp;&amp;</span><br><span class="line">                    counter[<span class="string">&#x27;E&#x27;</span>] &lt;= m &amp;&amp;</span><br><span class="line">                        counter[<span class="string">&#x27;R&#x27;</span>] &lt;= m &#123;</span><br><span class="line">            <span class="keyword">if</span> right-left+<span class="number">1</span> &lt; min &#123;</span><br><span class="line">                min = right-left+<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            counter[s[left]]++ <span class="comment">// 移除了子串的范围就应该放到其他的里面， counter始终是维护子串之外的数据</span></span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="将X减到0的最小操作数"><a href="#将X减到0的最小操作数" class="headerlink" title="将X减到0的最小操作数"></a>将X减到0的最小操作数</h5><ul><li>其实这一题和上面：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/submissions/">力扣-209-长度最小的子数组</a>是一模一样的， 可以理解为和为allSum-x的最小子串，稍微变了一下而已<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minOperations</span><span class="params">(nums []<span class="type">int</span>, x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    min := math.MaxInt</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    allSum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        allSum = allSum + v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 总和小于指定的值，肯定不符合</span></span><br><span class="line">    <span class="keyword">if</span> allSum &lt; x &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其实这一题可以转变一个思路，就是求满足子串总和=allSum-x的最小子串</span></span><br><span class="line">    otherSum := allSum - x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> right:=<span class="number">0</span>; right&lt;<span class="built_in">len</span>(nums); right++ &#123;</span><br><span class="line">        sum = sum + nums[right]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> sum &gt; otherSum &#123;</span><br><span class="line">            sum = sum - nums[left]</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sum == otherSum &#123;</span><br><span class="line">            subNumsLen := right-left+<span class="number">1</span></span><br><span class="line">            otherNumerLen := <span class="built_in">len</span>(nums) - subNumsLen</span><br><span class="line">            <span class="keyword">if</span> otherNumerLen &lt; min &#123;</span><br><span class="line">                min = otherNumerLen</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> min == math.MaxInt &#123;</span><br><span class="line">        min = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目大纲&quot;&gt;&lt;a href=&quot;#题目大纲&quot; class=&quot;headerlink&quot; title=&quot;题目大纲&quot;&gt;&lt;/a&gt;题目大纲&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/minimum-size-subarray-su
      
    
    </summary>
    
    
      <category term="算法" scheme="http://www.zhangfuguan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针" scheme="http://www.zhangfuguan.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>go适配器模式</title>
    <link href="http://www.zhangfuguan.top/2023/06/02/go%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhangfuguan.top/2023/06/02/go适配器模式/</id>
    <published>2023-06-02T15:53:20.000Z</published>
    <updated>2023-06-02T15:53:53.169Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := NewAdapter()</span><br><span class="line">a.Pay(<span class="string">&quot;张三&quot;</span>, <span class="number">12</span>, <span class="string">&quot;aliyun&quot;</span>)</span><br><span class="line">a.Pay(<span class="string">&quot;李四&quot;</span>, <span class="number">200</span>, <span class="string">&quot;wx&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AliyunPayInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">Pay(name <span class="type">string</span>, payment <span class="type">float64</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AliyunPay <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a AliyunPay)</span></span> Pay(name <span class="type">string</span>, payment <span class="type">float64</span>) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;用户【%s】支付宝支付金额【%f】元 \n&quot;</span>, name, payment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WxPayInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">Pay(name <span class="type">string</span>, payment <span class="type">float64</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> WxPay <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w WxPay)</span></span> Pay(name <span class="type">string</span>, payment <span class="type">float64</span>) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;用户【%s】微信支付金额【%f】元 \n&quot;</span>, name, payment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Apadter <span class="keyword">struct</span> &#123;</span><br><span class="line">AliyunPayInterface</span><br><span class="line">WxPayInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Apadter)</span></span> Pay(name <span class="type">string</span>, payment <span class="type">float64</span>, channel <span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> channel == <span class="string">&quot;aliyun&quot;</span> &#123;</span><br><span class="line">a.AliyunPayInterface.Pay(name, payment)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> channel == <span class="string">&quot;wx&quot;</span> &#123;</span><br><span class="line">a.WxPayInterface.Pay(name, payment)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;不支持的支付渠道&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAdapter</span><span class="params">()</span></span> Apadter &#123;</span><br><span class="line"><span class="keyword">return</span> Apadter&#123;</span><br><span class="line">AliyunPay&#123;&#125;,</span><br><span class="line">WxPay&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="设计模式" scheme="http://www.zhangfuguan.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>go观察者模式</title>
    <link href="http://www.zhangfuguan.top/2023/06/02/go%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhangfuguan.top/2023/06/02/go观察者模式/</id>
    <published>2023-06-02T15:50:53.000Z</published>
    <updated>2023-06-02T15:52:50.349Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sub := NewSubject(<span class="string">&quot;东北&quot;</span>)</span><br><span class="line">sub.Register(Observer&#123;</span><br><span class="line">Uid:  <span class="number">123</span>,</span><br><span class="line">Name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">sub.Register(Observer&#123;</span><br><span class="line">Uid:  <span class="number">124</span>,</span><br><span class="line">Name: <span class="string">&quot;李四&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sub.NotifyAll()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObserverInterface 观察者</span></span><br><span class="line"><span class="keyword">type</span> ObserverInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observer 具体观察者</span></span><br><span class="line"><span class="keyword">type</span> Observer <span class="keyword">struct</span> &#123;</span><br><span class="line">Uid  <span class="type">int32</span></span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o Observer)</span></span> Notify() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;观察者【%d】：%s \n&quot;</span>, o.Uid, o.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SubjectInterface 主体，也就是观察者模式的主体</span></span><br><span class="line"><span class="keyword">type</span> SubjectInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">Register(o ObserverInterface)</span><br><span class="line">Deregister(o ObserverInterface)</span><br><span class="line">NotifyAll()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Subject <span class="keyword">struct</span> &#123;</span><br><span class="line">observerMap <span class="keyword">map</span>[<span class="type">int32</span>]Observer</span><br><span class="line">name        <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSubject</span><span class="params">(name <span class="type">string</span>)</span></span> *Subject &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Subject&#123;</span><br><span class="line">name:        name,</span><br><span class="line">observerMap: <span class="keyword">map</span>[<span class="type">int32</span>]Observer&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span></span> Register(o Observer) &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := s.observerMap[o.Uid]; ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.observerMap[o.Uid] = o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span></span> Deregister(o Observer) &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := s.observerMap[o.Uid]; !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(s.observerMap, o.Uid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Subject)</span></span> NotifyAll() &#123;</span><br><span class="line"><span class="keyword">for</span> _, o := <span class="keyword">range</span> s.observerMap &#123;</span><br><span class="line">o.Notify()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="设计模式" scheme="http://www.zhangfuguan.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>dfs之查找二叉树最大深度</title>
    <link href="http://www.zhangfuguan.top/2023/06/01/dfs%E4%B9%8B%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>http://www.zhangfuguan.top/2023/06/01/dfs之查找二叉树最大深度/</id>
    <published>2023-06-01T15:47:21.000Z</published>
    <updated>2023-06-01T15:51:16.846Z</updated>
    
    <content type="html"><![CDATA[<p>传送到leetcode: <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">leetcode-104</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// dfs实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    startDeep := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, startDeep <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, startDeep <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        startDeep = startDeep + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> startDeep &gt; max &#123;</span><br><span class="line">                max = startDeep</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(node.Left, startDeep)</span><br><span class="line">        dfs(node.Right, startDeep)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(root, startDeep)</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;传送到leetcode: &lt;a href=&quot;https://leetcode.cn/problems/maximum-depth-of-binary-tree/&quot;&gt;leetcode-104&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="dfs" scheme="http://www.zhangfuguan.top/tags/dfs/"/>
    
      <category term="刷题变强" scheme="http://www.zhangfuguan.top/tags/%E5%88%B7%E9%A2%98%E5%8F%98%E5%BC%BA/"/>
    
  </entry>
  
  <entry>
    <title>go实现lru</title>
    <link href="http://www.zhangfuguan.top/2023/05/31/go%E5%AE%9E%E7%8E%B0lru/"/>
    <id>http://www.zhangfuguan.top/2023/05/31/go实现lru/</id>
    <published>2023-05-31T14:25:23.000Z</published>
    <updated>2023-05-31T14:37:00.166Z</updated>
    
    <content type="html"><![CDATA[<p>原理：定义lru结构的时候主要包含一个哈希表和双向链表，哈希表便于获取指定key的数据（复杂度O(1)），把每次热点数据都更新到表头，则从表头到表尾访问热度依次递减，溢出的时候直接删除表尾数据即可。</p><p><img src="/2023/05/31/go%E5%AE%9E%E7%8E%B0lru/6081685543618_.pic.jpg" alt="lru"></p><p>go代码实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Print(<span class="string">&quot;zlru...&quot;</span>)</span><br><span class="line"></span><br><span class="line">l := NewLruCache(<span class="number">5</span>)</span><br><span class="line">l.Put(<span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line">l.Put(<span class="number">2</span>, <span class="number">22</span>)</span><br><span class="line">l.Put(<span class="number">3</span>, <span class="number">33</span>)</span><br><span class="line">l.Put(<span class="number">4</span>, <span class="number">44</span>)</span><br><span class="line">l.Put(<span class="number">5</span>, <span class="number">55</span>)</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;case1-------------------------------&gt;&quot;</span>)</span><br><span class="line">log.Printf(<span class="string">&quot;head: %+v&quot;</span>, l.list.head)</span><br><span class="line">log.Printf(<span class="string">&quot;tail: %+v&quot;</span>, l.list.tail)</span><br><span class="line">log.Printf(<span class="string">&quot;len: %d&quot;</span>, l.size)</span><br><span class="line">l.list.Range()</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;case2-------------------------------&gt;&quot;</span>)</span><br><span class="line">l.Put(<span class="number">6</span>, <span class="number">66</span>)</span><br><span class="line">log.Printf(<span class="string">&quot;head: %+v&quot;</span>, l.list.head)</span><br><span class="line">log.Printf(<span class="string">&quot;tail: %+v&quot;</span>, l.list.tail)</span><br><span class="line">log.Printf(<span class="string">&quot;len: %d&quot;</span>, l.size)</span><br><span class="line">l.list.Range()</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;case3-------------------------------&gt;&quot;</span>)</span><br><span class="line">l.Get(<span class="number">3</span>)</span><br><span class="line">log.Printf(<span class="string">&quot;head: %+v&quot;</span>, l.list.head)</span><br><span class="line">log.Printf(<span class="string">&quot;tail: %+v&quot;</span>, l.list.tail)</span><br><span class="line">log.Printf(<span class="string">&quot;len: %d&quot;</span>, l.size)</span><br><span class="line">l.list.Range()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *linkList)</span></span> Range() &#123;</span><br><span class="line"><span class="keyword">for</span> node := l.head; node != <span class="literal">nil</span>; node = node.next &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;key: %d, value: %d \n&quot;</span>, node.key, node.value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表节点</span></span><br><span class="line"><span class="keyword">type</span> linkNode <span class="keyword">struct</span> &#123;</span><br><span class="line">key   <span class="type">int</span></span><br><span class="line">value <span class="type">int</span></span><br><span class="line">prev  *linkNode</span><br><span class="line">next  *linkNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="keyword">type</span> linkList <span class="keyword">struct</span> &#123;</span><br><span class="line">head *linkNode</span><br><span class="line">tail *linkNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lru缓存结构</span></span><br><span class="line"><span class="keyword">type</span> lruCache <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="built_in">cap</span>      <span class="type">int</span></span><br><span class="line">size     <span class="type">int</span></span><br><span class="line">cacheMap <span class="keyword">map</span>[<span class="type">int</span>]*linkNode</span><br><span class="line">list     *linkList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newNode</span><span class="params">(k, v <span class="type">int</span>)</span></span> *linkNode &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;linkNode&#123;</span><br><span class="line">key:   k,</span><br><span class="line">value: k,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLruCache 初始化一个新的lru</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLruCache</span><span class="params">(<span class="built_in">cap</span> <span class="type">int</span>)</span></span> *lruCache &#123;</span><br><span class="line">l := &amp;lruCache&#123;</span><br><span class="line"><span class="built_in">cap</span>:  <span class="built_in">cap</span>,</span><br><span class="line">size: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line">l.cacheMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*linkNode, <span class="number">0</span>)</span><br><span class="line">l.list = &amp;linkList&#123;</span><br><span class="line">head: <span class="literal">nil</span>,</span><br><span class="line">tail: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要是需要实现两个操作：Get/Put</span></span><br><span class="line"><span class="comment">// Get 获取指定key的值：</span></span><br><span class="line"><span class="comment">//     1. 如果key存在，则需要将该key所在的节点：（1）从当前位置删除，（2）移动到链表头部</span></span><br><span class="line"><span class="comment">//     2. 如果不存在直接返回-1</span></span><br><span class="line"><span class="comment">// Put 新增元素：</span></span><br><span class="line"><span class="comment">//     1. 如果key存在，则需要将该key所在的节点：（1）更新当前节点的值，（2）从当前位置删除，（2）移动到链表头部</span></span><br><span class="line"><span class="comment">//     2. 如果key不存在，则需要：（1）新生成一个节点NewNode, （2）将NewNode放在链表头部，（3）链表长度加1，如果此时链表长度未超过容量cap则直接返回，（4）如果加1后的链表长度超过容量则删除链表末尾节点，删除map中的元素</span></span><br><span class="line"><span class="comment">// 其实归结下来有以下几个基础操作：</span></span><br><span class="line"><span class="comment">//  （1）删除一个已经存在的元素 （2）删除链表中末尾元素（3）将元素放在链表头部</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *lruCache)</span></span> removeNode(node *linkNode) &#123;</span><br><span class="line"><span class="comment">// 如果node是最后一个元素, 并且prev元素不为空</span></span><br><span class="line"><span class="keyword">if</span> node.next == <span class="literal">nil</span> &amp;&amp; node.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">node.prev.next = <span class="literal">nil</span></span><br><span class="line">l.list.tail = node.prev</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果node是第一个元素, 并且next元素不为空</span></span><br><span class="line"><span class="keyword">if</span> node.prev == <span class="literal">nil</span> &amp;&amp; node.next != <span class="literal">nil</span> &#123;</span><br><span class="line">node.next.prev = <span class="literal">nil</span></span><br><span class="line">l.list.head = node.next</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只有一个元素</span></span><br><span class="line"><span class="keyword">if</span> node.prev == <span class="literal">nil</span> &amp;&amp; node.next == <span class="literal">nil</span> &#123;</span><br><span class="line">l.list.tail = <span class="literal">nil</span></span><br><span class="line">l.list.head = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除中间元素</span></span><br><span class="line">node.prev.next = node.next</span><br><span class="line">node.next.prev = node.prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *lruCache)</span></span> removeTail() &#123;</span><br><span class="line"><span class="keyword">if</span> l.list.tail == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">l.removeNode(l.list.tail)</span><br><span class="line"><span class="built_in">delete</span>(l.cacheMap, l.list.tail.key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *lruCache)</span></span> moveHead(node *linkNode) &#123;</span><br><span class="line"><span class="comment">// 一个元素都没有</span></span><br><span class="line"><span class="keyword">if</span> l.list.head == <span class="literal">nil</span> &#123;</span><br><span class="line">l.list.head = node</span><br><span class="line">l.list.tail = node</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">headNode := l.list.head</span><br><span class="line"><span class="comment">// 新节点的next指向头部节点</span></span><br><span class="line">node.next = headNode</span><br><span class="line"><span class="comment">// 头部节点的prev指向新节点</span></span><br><span class="line">headNode.prev = node</span><br><span class="line"><span class="comment">// 新节点的prev设置为nil</span></span><br><span class="line">node.prev = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 双向链表的头部指向新的节点</span></span><br><span class="line">l.list.head = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *lruCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 判断key是否存在</span></span><br><span class="line">node, ok := l.cacheMap[key]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点在之前的位置</span></span><br><span class="line">l.removeNode(node)</span><br><span class="line"><span class="comment">// 将节点移动到头部</span></span><br><span class="line">l.moveHead(node)</span><br><span class="line"><span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *lruCache)</span></span> Put(key, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 判断节点是否存在</span></span><br><span class="line">node, ok := l.cacheMap[key]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">// 如果不存在则需要新生产一个node， 并指向链表头部</span></span><br><span class="line">newNode := newNode(key, value)</span><br><span class="line"><span class="comment">// 向cap里面新增一对k/v</span></span><br><span class="line">l.cacheMap[key] = newNode</span><br><span class="line"><span class="comment">// 将新增的node放在链表头部</span></span><br><span class="line">l.moveHead(newNode)</span><br><span class="line"><span class="comment">// 链表长度加1</span></span><br><span class="line">l.size++</span><br><span class="line"><span class="comment">// 如果长度超过容量则需要删除链表末尾元素</span></span><br><span class="line"><span class="keyword">if</span> l.size &gt; l.<span class="built_in">cap</span> &#123;</span><br><span class="line">l.removeTail()</span><br><span class="line">l.size--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果新增元素已经存在</span></span><br><span class="line"><span class="comment">// 更新元素的值</span></span><br><span class="line">node.value = value</span><br><span class="line"><span class="comment">// 将元素从当前位置删除</span></span><br><span class="line">l.removeNode(node)</span><br><span class="line"><span class="comment">// 将元素移动到链表头部</span></span><br><span class="line">l.moveHead(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原理：定义lru结构的时候主要包含一个哈希表和双向链表，哈希表便于获取指定key的数据（复杂度O(1)），把每次热点数据都更新到表头，则从表头到表尾访问热度依次递减，溢出的时候直接删除表尾数据即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/05/31/go%E5%AE
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>go容易忽视的黑坑系列2</title>
    <link href="http://www.zhangfuguan.top/2023/05/28/go%E5%AE%B9%E6%98%93%E5%BF%BD%E8%A7%86%E7%9A%84%E9%BB%91%E5%9D%91%E7%B3%BB%E5%88%972/"/>
    <id>http://www.zhangfuguan.top/2023/05/28/go容易忽视的黑坑系列2/</id>
    <published>2023-05-28T13:15:26.000Z</published>
    <updated>2023-05-31T14:23:24.450Z</updated>
    
    <content type="html"><![CDATA[<ol><li>推断下面代码输出结果：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">f(i<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可能有同学会测试为：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>但实际是：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">x</span><br></pre></td></tr></table></figure>这是因为main函数在构造的时候全局f函数已经构造完成，所以使用的是全局f函数。而且如果改成为我们想像的逻辑，反而会报错：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fi := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">fi(i<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">314</span>:<span class="number">4</span>: undefined: fi</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;推断下面代码输出结果：&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/spa
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>N皇后问题</title>
    <link href="http://www.zhangfuguan.top/2023/05/28/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <id>http://www.zhangfuguan.top/2023/05/28/N皇后问题/</id>
    <published>2023-05-28T12:20:23.000Z</published>
    <updated>2023-05-28T12:24:20.595Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否冲突</span></span><br><span class="line"><span class="comment">//  0/0  0/1  0/2  0/3</span></span><br><span class="line"><span class="comment">//  1/0  1/1  1/2  1/3</span></span><br><span class="line"><span class="comment">//  2/0  2/1  2/2  2/3</span></span><br><span class="line"><span class="comment">//  3/0  3/1  3/2  3/3</span></span><br><span class="line"><span class="comment">// 1. 判断是否属于同一列</span></span><br><span class="line"><span class="comment">// 2. 判断左边斜线上是否有冲突</span></span><br><span class="line"><span class="comment">//    *</span></span><br><span class="line"><span class="comment">//      *</span></span><br><span class="line"><span class="comment">//        *</span></span><br><span class="line"><span class="comment">// 2. 判断右边斜线上是否有冲突</span></span><br><span class="line"><span class="comment">//           *</span></span><br><span class="line"><span class="comment">//          *</span></span><br><span class="line"><span class="comment">//        *</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalNQueens</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 结果</span></span><br><span class="line">    res := <span class="built_in">make</span>([][]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 初始化path</span></span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt; n ; i++ &#123;</span><br><span class="line">        path = <span class="built_in">append</span>(path, strings.Repeat(<span class="string">&quot;.&quot;</span>, n))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从第一行开始</span></span><br><span class="line">    row := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    backtrack(row, path, &amp;res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(row <span class="type">int</span>, path []<span class="type">string</span>, res *[][]<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(path) == row &#123;</span><br><span class="line">        temp := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(path))</span><br><span class="line">        <span class="built_in">copy</span>(temp, path)</span><br><span class="line">        *res = <span class="built_in">append</span>(*res, temp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n := <span class="built_in">len</span>(path)</span><br><span class="line">    <span class="keyword">for</span> col := <span class="number">0</span>; col&lt;n; col++ &#123;</span><br><span class="line">        <span class="keyword">if</span> !isConflict(path, row, col) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rowBytes := []<span class="type">byte</span>(path[row])</span><br><span class="line">        rowBytes[col] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">        path[row] = <span class="type">string</span>(rowBytes)</span><br><span class="line"></span><br><span class="line">        backtrack(row+<span class="number">1</span>, path, res)</span><br><span class="line"></span><br><span class="line">        rowBytes[col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">        path[row] = <span class="type">string</span>(rowBytes)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isConflict</span><span class="params">(path []<span class="type">string</span>, row, col <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 同一列</span></span><br><span class="line">    n := <span class="built_in">len</span>(path)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> path[i][col] == <span class="string">&#x27;Q&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左上方</span></span><br><span class="line">    r := row<span class="number">-1</span></span><br><span class="line">    c := col<span class="number">-1</span> </span><br><span class="line">    <span class="keyword">for</span> r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> path[r][c] == <span class="string">&#x27;Q&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        c = c - <span class="number">1</span></span><br><span class="line">        r = r - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右上方</span></span><br><span class="line">    r = row<span class="number">-1</span></span><br><span class="line">    c = col+ <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> r &gt;=<span class="number">0</span> &amp;&amp; c &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> path[r][c] == <span class="string">&#x27;Q&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        c = c + <span class="number">1</span></span><br><span class="line">        r = r - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="算法" scheme="http://www.zhangfuguan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯" scheme="http://www.zhangfuguan.top/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>goroutine池简单实现</title>
    <link href="http://www.zhangfuguan.top/2023/05/21/goroutine%E6%B1%A0%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.zhangfuguan.top/2023/05/21/goroutine池简单实现/</id>
    <published>2023-05-21T14:00:43.000Z</published>
    <updated>2023-05-21T14:48:34.541Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不可复用的简单实现"><a href="#不可复用的简单实现" class="headerlink" title="不可复用的简单实现"></a>不可复用的简单实现</h3><p>其实就是基于有缓冲channel的特性，每创建一个goroutine就向goroutine里面发送一个数据，goroutine任务完成之后就消费一条channel里面的数据，当channel满了之后就阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 最多50个goroutine</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">100</span>)</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++ &#123;</span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Done()</span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;()</span><br><span class="line">DoSomething(num)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">(num <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;k....: %d \n&quot;</span>, num)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方案实现简单，但缺点是会不断创建和销毁goroutine，不可服用，性能较差。</p><h3 id="可复用的pool"><a href="#可复用的pool" class="headerlink" title="可复用的pool"></a>可复用的pool</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">jobParams := <span class="built_in">make</span>([]JobParams, <span class="number">0</span>)</span><br><span class="line">jobParams = <span class="built_in">append</span>(jobParams,</span><br><span class="line">JobParams&#123; <span class="string">&quot;张三&quot;</span>, <span class="number">18</span>&#125;,</span><br><span class="line">JobParams&#123; <span class="string">&quot;李斯&quot;</span>, <span class="number">28</span>&#125;,</span><br><span class="line">JobParams&#123; <span class="string">&quot;赵武&quot;</span>, <span class="number">8</span>&#125;,</span><br><span class="line">JobParams&#123; <span class="string">&quot;王二&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">JobParams&#123; <span class="string">&quot;利好&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">JobParams&#123; <span class="string">&quot;六七&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">JobParams&#123; <span class="string">&quot;问候&quot;</span>, <span class="number">23</span>&#125;,</span><br><span class="line">)</span><br><span class="line">jobParamsCh := <span class="built_in">make</span>(<span class="keyword">chan</span> JobParams, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">workPool(<span class="number">2</span>, jobParamsCh)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> jobParams &#123;</span><br><span class="line">jobParamsCh &lt;- v</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;Done...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workPool</span><span class="params">(size <span class="type">int</span>, jobParamCh <span class="keyword">chan</span> JobParams)</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i&lt;= size; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> params := &lt;-jobParamCh:</span><br><span class="line">Job(params)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;wait...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> JobParams <span class="keyword">struct</span> &#123;</span><br><span class="line">UserName <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Job</span><span class="params">(params JobParams)</span></span> &#123;</span><br><span class="line"><span class="comment">// doSomethings for example:</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Hello, I&#x27;m %s and %d years old. \n&quot;</span>, params.UserName, params.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实就在在每个goroutine里面去获取需要处理的参数，然后调用对应的逻辑函数逐个处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;不可复用的简单实现&quot;&gt;&lt;a href=&quot;#不可复用的简单实现&quot; class=&quot;headerlink&quot; title=&quot;不可复用的简单实现&quot;&gt;&lt;/a&gt;不可复用的简单实现&lt;/h3&gt;&lt;p&gt;其实就是基于有缓冲channel的特性，每创建一个goroutine就向gorout
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="goroutine" scheme="http://www.zhangfuguan.top/tags/goroutine/"/>
    
  </entry>
  
  <entry>
    <title>go容易忽视的黑坑系列1</title>
    <link href="http://www.zhangfuguan.top/2023/05/15/go%E5%AE%B9%E6%98%93%E5%BF%BD%E8%A7%86%E7%9A%84%E9%BB%91%E5%9D%91%E7%B3%BB%E5%88%971/"/>
    <id>http://www.zhangfuguan.top/2023/05/15/go容易忽视的黑坑系列1/</id>
    <published>2023-05-15T15:58:02.000Z</published>
    <updated>2023-05-15T16:02:42.339Z</updated>
    
    <content type="html"><![CDATA[<ol><li>先看下面代码，是否有问题。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">const</span> sh = <span class="string">&quot;zhang&quot;</span></span><br><span class="line">   fmt.Println(&amp;sh, sh)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> nl <span class="type">string</span> = <span class="string">&quot;san&quot;</span></span><br><span class="line">   fmt.Println(&amp;nl, nl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  test_all  go run main.go</span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./main.go:7:14: cannot take the address of sh</span><br></pre></td></tr></table></figure><p>在go中，不同于变量是在运行时分配内存空间，常量通常会被编译器在预处理阶段直接展开，作为指令数据使用，所以常量无法寻址。</p><ol start="2"><li>单向channel关闭</li></ol><ul><li>只读channel不允许关闭</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1000</span>)</span><br><span class="line">ch &lt;- <span class="string">&quot;name&quot;</span></span><br><span class="line">RecvSim(ch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RecvSim</span><span class="params">(ch &lt;- <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  test_all  go run main.go</span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./main.go:35:7: invalid operation: close(ch) (cannot close receive-only channel)</span><br></pre></td></tr></table></figure><ul><li>只写channel可以关闭</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1000</span>)</span><br><span class="line">SendSim(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendSim</span><span class="params">(ch <span class="keyword">chan</span> &lt;- <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">ch &lt;- <span class="string">&quot;zzz...&quot;</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>判断下面代码输出的结果：<br>情况A:</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">ls []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(t T)</span></span> &#123;</span><br><span class="line">t.ls[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := T&#123;</span><br><span class="line">ls: []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">foo(t)</span><br><span class="line"></span><br><span class="line">fmt.Println(t.ls)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确答案是：[100,2,3]</p><p>情况B:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">ls []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(t T)</span></span> &#123;</span><br><span class="line">t.ls = <span class="built_in">append</span>(t.ls, <span class="number">100</span>)</span><br><span class="line">t.ls[<span class="number">0</span>] = <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := T&#123;</span><br><span class="line">ls: []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">foo(t)</span><br><span class="line"></span><br><span class="line">fmt.Println(t.ls)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确答案：[1,2,3]</p><p>函数foo参数t虽然是传传递，但是复制后的参数t的ls字段最开始指向底层的数组是公用的，所以情况A修改了第一个元素的值也会影响到原来的变量；而情况B犹豫追加了一个元素，导致函数foo的参数t底层数据进行了重新内存分配，指向了新的底层数组，所以不会影响原来的值。</p><ol start="4"><li>context.WithValue容易忽视的陷阱。</li></ol><p>查看下面的代码，说出下面代码输出的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ctx0 := context.Background()</span><br><span class="line">   ctx := context.WithValue(ctx0, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhangliang&quot;</span>)</span><br><span class="line">   ctx = context.WithValue(ctx0, <span class="string">&quot;age&quot;</span>, <span class="number">12</span>)</span><br><span class="line">   fmt.Println(ctx.Value(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">   fmt.Println(ctx.Value(<span class="string">&quot;age&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确结果是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  test_all  <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p>这是因为每组context只允许存储一对key-value，后面的age把前面的name覆盖了。正确写法是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx0 := context.Background()</span><br><span class="line">ctx1 := context.WithValue(ctx0, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhangliang&quot;</span>)</span><br><span class="line">ctx2 := context.WithValue(ctx1, <span class="string">&quot;age&quot;</span>, <span class="number">12</span>)</span><br><span class="line">fmt.Println(ctx2.Value(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">fmt.Println(ctx2.Value(<span class="string">&quot;age&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  test_all  go run main.go</span><br><span class="line">zhangliang</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>此时的ctx2结构如下：<br><img src="/2023/05/15/go%E5%AE%B9%E6%98%93%E5%BF%BD%E8%A7%86%E7%9A%84%E9%BB%91%E5%9D%91%E7%B3%BB%E5%88%971/bO7tSIlTMeu38TUh6Qrl6S2zdLf6kxlupmIpsGnlnys.png" alt="001"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;先看下面代码，是否有问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉搜索树插入于删除操作</title>
    <link href="http://www.zhangfuguan.top/2023/03/26/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E4%BA%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.zhangfuguan.top/2023/03/26/二叉搜索树插入于删除操作/</id>
    <published>2023-03-26T13:33:50.000Z</published>
    <updated>2023-05-15T15:56:03.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>二叉排序树（Binary Sarech&#x2F;Sort Tree）或者是一颗空树；或者是具有如下性质的二叉树：</p><blockquote><p>(1) 若它的左子树不空，则 <strong>左子树</strong> 上所有结点的值 <strong>均小于</strong> 它的根结点的值；<br>(2) 若它的右子树不空，则 <strong>右子树</strong> 上所有结点的值 <strong>均大于</strong> 它的根结点的值；<br>(3) 它的 <strong>左、右子树又分别为二叉排序树</strong> 。</p></blockquote><p>比如一下值: 8、3、10、1、6、14、4、7、13，构造BTS的过程如下：<br><img src="/2023/03/26/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E4%BA%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/1.jpeg"></p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Value <span class="type">string</span></span><br><span class="line">    Left *Node</span><br><span class="line">    Right *Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SearchBST 这里假设值都是int，不做异常预期判断了，咱们就简单理解算法即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchBST</span><span class="params">(targetNode *Node,value <span class="type">int</span>)</span></span> *Node &#123;</span><br><span class="line"><span class="comment">// 如果根节点为nil， 则肯定不存在</span></span><br><span class="line"><span class="keyword">if</span> targetNode ==  <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value == targetNode.Value.(<span class="type">int</span>)  &#123;</span><br><span class="line"><span class="keyword">return</span> targetNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value &lt; targetNode.Value.(<span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> SearchBST(targetNode.Left, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value &gt; targetNode.Value.(<span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> SearchBST(targetNode.Right, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertBST</span><span class="params">(targetNode *Node, value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> targetNode == <span class="literal">nil</span> &#123;</span><br><span class="line">targetNode.Value = value</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> targetNode.Value.(<span class="type">int</span>) == value &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value &lt; targetNode.Value.(<span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 如果当前节点不存在左子树，则将该目标节点作为当前节点的左子树</span></span><br><span class="line"><span class="keyword">if</span> targetNode.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">targetNode.Left = &amp;Node&#123;</span><br><span class="line">Value: value,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InsertBST(targetNode.Left, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value &gt; targetNode.Value.(<span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 如果当前节点不存在右子树，则将该目标节点作为当前节点的右子树</span></span><br><span class="line"><span class="keyword">if</span> targetNode.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">targetNode.Right = &amp;Node&#123;</span><br><span class="line">Value: value,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">InsertBST(targetNode.Right, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除二叉搜索树的节点相对而言复杂一点，如果待删除的节点同时包含左右子树，删除后如何恢复搜索树是一个问题。<br><img src="/2023/03/26/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E4%BA%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/3.jpeg"><br>比如删除节点8， 那么是选举3作为根节点还是10呢？所以就需要我们一点点去梳理：</p><ol><li>如果删除的节点是叶子结点（即没有左右子树），那么直接删除即可，比如上面的1、7、9、13.</li><li>如果删除的节点只有左子树或者只有右子树，则删除后将子节点直接指向删除节点的位置即可，比如6、14</li><li>还有一种情况就是同时存在左右子树的情况，比如8，为了维持删除后的树依然符合二叉搜索树特性，其实可以将左子树的最大值或者右子树的最小值转移到删除点位置比如将7放在8的位置，但是这里的7是叶子结点，直接删除即可，如果7还包含左右子树，其实可以递归删除替换即可。我们可以用一个比较大的BST来举例：<br><img src="/2023/03/26/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E4%BA%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/2.jpeg"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteBST</span><span class="params">(node *Node, value <span class="type">int</span>)</span></span> *Node &#123;</span><br><span class="line"><span class="comment">// 如果二叉搜索树为nil，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前节点的值等于待删除值</span></span><br><span class="line"><span class="keyword">if</span> node.Value == value &#123;</span><br><span class="line"><span class="comment">// 如果当前节点没有左右子树，则直接删除</span></span><br><span class="line"><span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">node = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有右边子树，直接用右子树覆盖</span></span><br><span class="line"><span class="keyword">if</span> node.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">node = node.Right</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有左子树，直接用左子树覆盖</span></span><br><span class="line"><span class="keyword">if</span> node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">node = node.Left</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &amp;&amp; node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 找到左子树中最大值，将其设置为当前的值</span></span><br><span class="line">maxInLeft := FindMaxInNodeBST(node.Left)</span><br><span class="line">node.Value = maxInLeft.Value</span><br><span class="line">node.Left = DeleteBST(node.Left, maxInLeft.Value.(<span class="type">int</span>))</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有左子树，并且当前节点的值小于目标值，则进入左子树递归查找删除</span></span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &amp;&amp; value &lt; node.Value.(<span class="type">int</span>)  &#123;</span><br><span class="line">node.Left =  DeleteBST(node.Left, value)</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有右子树，并且当前节点的值大于目标值，则进入右子树递归查找删除</span></span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &amp;&amp; value &gt; node.Value.(<span class="type">int</span>) &#123;</span><br><span class="line">node.Right = DeleteBST(node.Right, value)</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindMaxInNodeBST</span><span class="params">(node *Node)</span></span> *Node &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树中的最大值肯定在根节点或者右子树中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果左右子树都为空，则就是当前节点</span></span><br><span class="line"><span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;二叉排序树（Binary Sarech&amp;#x2F;Sort Tree）或者是一颗空树；或者是具有如下性质的二叉树：&lt;/p&gt;
&lt;blockqu
      
    
    </summary>
    
    
      <category term="算法" scheme="http://www.zhangfuguan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://www.zhangfuguan.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历</title>
    <link href="http://www.zhangfuguan.top/2023/03/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <id>http://www.zhangfuguan.top/2023/03/25/二叉树遍历/</id>
    <published>2023-03-24T16:16:01.000Z</published>
    <updated>2023-03-24T16:24:12.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>前序遍历：递归遍历根-&gt;左-&gt;右</li><li>中序遍历：递归遍历左-&gt;根-&gt;右</li><li>后续遍历：递归遍历左-&gt;右-&gt;中</li><li>层序遍历：由根节点开始一层层的遍历</li></ul><p>其实前序遍历、中序遍历、后序遍历里面的前、中、后指的是根结点的位置。以下面这棵树来举例说明。<br><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/yuque_mind.jpeg"></p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Value <span class="type">string</span></span><br><span class="line">    Left *Node</span><br><span class="line">    Right *Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>前序遍历要求先遍历根节点，然后遍历左子树，左后便利右子树。注意这里指的是【子树】不是孩子。所以遍历顺序为：<br>A,B,D,H,I,E,J,C,F,K,G</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreRange</span><span class="params">(node *Node)</span></span> []<span class="type">string</span>  &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">list := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">list = <span class="built_in">append</span>(list, node.Value)</span><br><span class="line"></span><br><span class="line">leftList := PreRange(node.Left)</span><br><span class="line"><span class="keyword">if</span> leftList != <span class="literal">nil</span> &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, leftList...)</span><br><span class="line">&#125;</span><br><span class="line">rightList := PreRange(node.Right)</span><br><span class="line"><span class="keyword">if</span> rightList != <span class="literal">nil</span> &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, rightList...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>中序遍历要求先遍历左子树，然后遍历根节点，最后遍历右子树。所以顺序为：<br>H,D,I,B,E,J,A,F,K,C,G</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MidRange</span><span class="params">(node *Node)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">list := <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line">leftList := MidRange(node.Left)</span><br><span class="line"><span class="keyword">if</span> leftList != <span class="literal">nil</span> &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, leftList...)</span><br><span class="line">&#125;</span><br><span class="line">list = <span class="built_in">append</span>(list, node.Value)</span><br><span class="line">rightList := MidRange(node.Right)</span><br><span class="line"><span class="keyword">if</span> rightList != <span class="literal">nil</span> &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, rightList...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><p>后序遍历要求先遍历左子树，然后遍历右子树，最后遍历根节点。所以顺序为：<br>H,I,D,J,E,B,K,F,G,C,A</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SufRange</span><span class="params">(node *Node)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">list := <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line">leftList := SufRange(node.Left)</span><br><span class="line"><span class="keyword">if</span> leftList != <span class="literal">nil</span> &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, leftList...)</span><br><span class="line">&#125;</span><br><span class="line">rightList := SufRange(node.Right)</span><br><span class="line"><span class="keyword">if</span> rightList != <span class="literal">nil</span> &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, rightList...)</span><br><span class="line">&#125;</span><br><span class="line">list = <span class="built_in">append</span>(list, node.Value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>层序遍历其实就是从根节点开始从左到右一层层开始遍历所有节点， 所以顺序为：<br>A,B,C,D,E,F,G,H,I,J,K</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LevelTraversal</span><span class="params">(node *Node)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nodeList := <span class="built_in">make</span>([]*Node, <span class="number">0</span>)</span><br><span class="line">nodeList = <span class="built_in">append</span>(nodeList, node)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> RecursionTraversal(nodeList)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RecursionTraversal</span><span class="params">(nodeList []*Node)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nodeList) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list := <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line">nextNodeList := <span class="built_in">make</span>([]*Node, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, node := <span class="keyword">range</span> nodeList &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, node.Value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">nextNodeList = <span class="built_in">append</span>(nextNodeList, node.Left)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">nextNodeList =<span class="built_in">append</span>(nextNodeList, node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nextNodeList) &gt; <span class="number">0</span> &#123;</span><br><span class="line">s := RecursionTraversal(nextNodeList)</span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span> &#123;</span><br><span class="line"> list = <span class="built_in">append</span>(list, s...)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方式&quot;&gt;&lt;a href=&quot;#方式&quot; class=&quot;headerlink&quot; title=&quot;方式&quot;&gt;&lt;/a&gt;方式&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://www.zhangfuguan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://www.zhangfuguan.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁方案对比</title>
    <link href="http://www.zhangfuguan.top/2023/03/03/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/"/>
    <id>http://www.zhangfuguan.top/2023/03/03/分布式锁方案对比/</id>
    <published>2023-03-02T16:15:58.000Z</published>
    <updated>2023-03-08T15:28:32.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>当我们对一份数据进行修改的时候需要先读取，再修改，由于读取和修改不是原子操作，在并发的情况下，无法保证前后数据是一致的，在单点服务中我们可以使用本地锁来实现（比如：sync.Mutex），但是对于分布式系统服务，本地锁却无能为力。这时候就需要使用分布式锁来保证数据的一致性。</p><p><img src="/2023/03/03/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/iOLsHtH8yF9PIkHbVzQntyxXNNzV7__KSfDDXUZftsk.png" alt="image"></p><p>很多应用场景是需要系统保证幂等性的（如api服务或消息消费者），并发情况下或消息重复很容易造成系统重入，那么分布式锁是保障幂等的一个重要手段。还有一种场景就是商城做抢购活动、司机抢单等场景需要使用分布式锁来防止出现“超卖”现象。</p><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><ul><li>基于数据库的唯一索引</li><li>基于redis的setnx</li><li>基于zookeeper</li></ul><h3 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h3><h4 id="基于唯一索引"><a href="#基于唯一索引" class="headerlink" title="基于唯一索引"></a>基于唯一索引</h4><p>基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含方法名（或者变量等）等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p><ul><li>新建一张表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `method_lock`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `method_lock` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `method_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;锁定的方法名&#x27;</span>,</span><br><span class="line">  `<span class="keyword">desc</span>` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注信息&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uidx_method_name` (`method_name`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;锁定中的方法&#x27;</span>;</span><br></pre></td></tr></table></figure><p>核心就是利用唯一索引的不可重复插入的特性，来控制锁的获取是释放。</p><ul><li>想要执行某个方法，就使用这个方法名向表中插入数据：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> method_lock (method_name, <span class="keyword">desc</span>) <span class="keyword">VALUES</span> (<span class="string">&#x27;methodName&#x27;</span>, <span class="string">&#x27;测试的methodName&#x27;</span>);</span><br></pre></td></tr></table></figure><p>因为我们对<code>method_name</code>做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p><ul><li>成功插入则获取锁，执行完成后删除对应的行数据释放锁：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> method_lock <span class="keyword">where</span> method_name <span class="operator">=</span><span class="string">&#x27;methodName&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</p><p>乐观锁大多数是基于数据版本(version)的记录机制实现的。何谓数据版本号？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表添加一个 “version”字段来实现读取出数据时，将此版本号一同读出，之后更新时，对此版本号加1。在更新过程中，会对版本号进行比较，如果是一致的，没有发生改变，则会成功执行本次操作；如果版本号不一致，则会更新失败。其实也可以为使用表的updated_at字段记录每次更新的时间戳，使用时间戳作为version字段。</p><p>乐观锁的优点比较明显，由于在检测数据冲突时并不依赖数据库本身的锁机制，不会影响请求的性能，当产生并发且并发量较小的时候只有少部分请求会失败。缺点是需要对表的设计增加额外的字段，增加了数据库的冗余，另外，当应用并发量高的时候，version值在频繁变化，则会导致大量请求失败，影响系统的可用性。数据库锁都是作用于同一行数据记录上，这就导致一个明显的缺点，在一些特殊场景，如大促、秒杀等活动开展的时候，大量的请求同时请求同一条记录的行锁（update），会对数据库产生很大的写压力。所以综合数据库乐观锁的优缺点，乐观锁比较适合并发量不高，并且写操作不频繁的场景。</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</p><p>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit&#x3D;0;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">0.</span>开始事务</span><br><span class="line"><span class="keyword">begin</span>;<span class="operator">/</span><span class="keyword">begin</span> work;<span class="operator">/</span><span class="keyword">start</span> transaction; (三者选一就可以)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">1.</span>查询出商品信息</span><br><span class="line"><span class="keyword">select</span> status <span class="keyword">from</span> t_goods <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">2.</span>根据商品信息生成订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_orders (id,goods_id) <span class="keyword">values</span> (<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">3.</span>修改商品status为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> status<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">4.</span>提交事务</span><br><span class="line"><span class="keyword">commit</span>;<span class="operator">/</span><span class="keyword">commit</span> work;</span><br></pre></td></tr></table></figure><p>在悲观锁中，每一次行数据的访问都是独占的，只有当正在访问该行数据的请求事务提交以后，其他请求才能依次访问该数据，否则将阻塞等待锁的获取。悲观锁可以严格保证数据访问的安全。但是缺点也明显，即每次请求都会额外产生加锁的开销且未获取到锁的请求将会阻塞等待锁的获取，在高并发环境下，容易造成大量请求阻塞，影响系统可用性。另外，悲观锁使用不当还可能产生死锁的情况。</p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><ol><li>因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换；  </li><li>不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁；  </li><li>没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；  </li><li>不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。  </li><li>在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。</li></ol><h3 id="基于redis的setnx"><a href="#基于redis的setnx" class="headerlink" title="基于redis的setnx"></a>基于redis的setnx</h3><ol><li>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</li></ol><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SETNX &#123;ResourceURI&#125; &#123;UUID&#125;</span><br><span class="line">EXPIRE &#123;ResourceURI&#125; &#123;timeout&#125; </span><br></pre></td></tr></table></figure><ol start="2"><li>释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</li></ol><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 比对 value 与 标识</span><br><span class="line">if (redis.get(&quot;lock:168&quot;).equals(random_value))&#123;</span><br><span class="line">   redis.del(&quot;lock:168&quot;); //比对成功则删除</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h4><ol><li>setnx和expire操作的非原子特性会导致死锁问题。协程A执行setnx命令成功，结果运行协程A的服务发生异常重启，导致expire命令没有执行，那么就会由于锁没有设置超时时间形成死锁。</li><li>A线程拿到锁超时释放，但是A依旧在执行自己的业务逻辑，此时B线程立刻获得锁，B也开始执行。这显然是不被允许的，一般会采取加大过期时间或者添加守护线程，go中也可以使用context设置过期时间。</li><li>上述方案无法达到不可重入，即在同一个协程中多次加锁。可以在本地维护一个map，map的key为锁标识，value为加锁次数。 每次加锁的时候加1， 重新设置过期时间，每次释放锁的时候减1，当计数小于或等于1的时候执行删除操作删除</li></ol><h3 id="基于zookeeper"><a href="#基于zookeeper" class="headerlink" title="基于zookeeper"></a>基于zookeeper</h3><p>利用zookeeper的临时有序节点和wathcer机制来实现分布式锁的功能。具体实现步骤如下：</p><ol><li>创建一个目录lock</li><li>每个节点尝试获取锁时，首先在zookeeper的lock目录下创建一个znode节点，zookeeper的有序临时节点会自动根据创建先后顺序给节点编号。</li></ol><p><img src="/2023/03/03/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/Q8r39VsHbcEV13aoTmoBzcwJrtSP7XxGDm2s44df94Y.png" alt="image"></p><ol start="3"><li>判断当前服务节点创建的znode节点是最小节点。</li></ol><ul><li>如果序列号是最小的，则成功获取到锁。执行完操作后，把创建的节点给删掉。</li><li>如果不是，则监听比自己要小 1 的节点变化。直到拿到自己是最小的节点时获得锁。</li></ul><h4 id="缺陷-2"><a href="#缺陷-2" class="headerlink" title="缺陷"></a>缺陷</h4><p>虽然zookeeper具备高可用、可重入、阻塞锁特性，可解决失效死锁问题，但是因为需要频繁的创建和删除节点，性能上不如Redis方式。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/">小米技术团队-分布式锁的实现之 redis 篇</a></p><p><a href="https://www.cnblogs.com/liuqingzheng/p/11080501.html">刘清政的博客-分布式锁</a></p><p><a href="https://chai2010.cn/advanced-go-programming-book/ch6-cloud/ch6-02-lock.html#623-%E5%9F%BA%E4%BA%8E-redis-%E7%9A%84-setnx">go高级编程-分布式锁</a></p><p><a href="https://tech.meituan.com/2017/03/17/cache-about.html">美团技术团队-缓存那些事</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式锁&quot;&gt;&lt;a href=&quot;#分布式锁&quot; class=&quot;headerlink&quot; title=&quot;分布式锁&quot;&gt;&lt;/a&gt;分布式锁&lt;/h1&gt;&lt;p&gt;当我们对一份数据进行修改的时候需要先读取，再修改，由于读取和修改不是原子操作，在并发的情况下，无法保证前后数据是一致的，在单
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="微服务" scheme="http://www.zhangfuguan.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="高并发" scheme="http://www.zhangfuguan.top/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>璃月</title>
    <link href="http://www.zhangfuguan.top/2022/09/10/%E7%92%83%E6%9C%88/"/>
    <id>http://www.zhangfuguan.top/2022/09/10/璃月/</id>
    <published>2022-09-09T16:07:51.000Z</published>
    <updated>2022-09-09T16:31:03.259Z</updated>
    
    <content type="html"><![CDATA[<p>车遥遥，马憧憧。<br>君游东山东复东，安得奋飞逐西风。<br>愿我如星君如月，夜夜流光相皎洁。<br>月暂晦，星常明。<br>留明待月复，三五共盈盈。</p><hr><p><img src="/2022/09/10/%E7%92%83%E6%9C%88/1.png" alt="1"></p><p><img src="/2022/09/10/%E7%92%83%E6%9C%88/2.png" alt="1"></p><p><img src="/2022/09/10/%E7%92%83%E6%9C%88/3.png" alt="1"></p><p><img src="/2022/09/10/%E7%92%83%E6%9C%88/4.png" alt="1"></p><p><img src="/2022/09/10/%E7%92%83%E6%9C%88/5.png" alt="1"></p><p><img src="/2022/09/10/%E7%92%83%E6%9C%88/6.png" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;车遥遥，马憧憧。&lt;br&gt;君游东山东复东，安得奋飞逐西风。&lt;br&gt;愿我如星君如月，夜夜流光相皎洁。&lt;br&gt;月暂晦，星常明。&lt;br&gt;留明待月复，三五共盈盈。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;/2022/09/10/%E7%92%83%E6%9C%88/1.png&quot; 
      
    
    </summary>
    
    
      <category term="意味" scheme="http://www.zhangfuguan.top/tags/%E6%84%8F%E5%91%B3/"/>
    
  </entry>
  
  <entry>
    <title>基于GoogleAuthenticator的MFA多重身份认证</title>
    <link href="http://www.zhangfuguan.top/2022/09/09/%E5%9F%BA%E4%BA%8EGoogleAuthenticator%E7%9A%84MFA%E5%A4%9A%E9%87%8D%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/"/>
    <id>http://www.zhangfuguan.top/2022/09/09/基于GoogleAuthenticator的MFA多重身份认证/</id>
    <published>2022-09-08T16:22:26.000Z</published>
    <updated>2022-09-09T16:01:27.878Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>对于一个需要身份认证的系统而言，账号和密码是必备的，而敏感系数比较高的应用，固定的账号和密码不足以保护其安全性。通常会采集多种信息来确认当前访问者的身份，即多因素认证（Multi-factor authentication，MFA）,常见的多因素认证方式：</p><ul><li>短信验证码</li><li>邮件验证码</li></ul><p>上面介绍的几种方式在成本，可用性，便捷性上来说都表现不是很好，比如短信和邮件都需要收费，同时都必须保证网络在线。</p><p>Google现在也推荐用户启用两步验证（2 Factor Authentication）功能，并且除了以短信或者电话的方式发送一次性密码之外，还提供了另一种基于时间的一次性密码（Time-based One-time Password，简称TOTP），只需要在手机上安装密码生成应用程序，就可以生成一个随着时间变化的一次性密码，用于帐户验证，而且这个应用程序不需要连接网络即可工作。Google的TOTP方案其实是基于HOTP(HMAC-based One-Time Password)，所以在介绍TOTP之前先了解一下HOTP的原理。</p><h3 id="HOTP"><a href="#HOTP" class="headerlink" title="HOTP"></a>HOTP</h3><p>HOTP是一种基于散列消息验证码（HMAC）生成一次性密码值的算法，HMAC利用哈希算法，以一个密钥和一个消 息为输入，生成一个消息摘要作为输出。</p><p>进行验证时，客户端对密钥和计数器的组合(K,C)使用HMAC（Hash-based Message Authentication Code）算法计算一次性密码，公式如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))</span><br></pre></td></tr></table></figure><ul><li>K为双方协定的密钥，需要自行保存，不要泄漏</li></ul><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otpauth://totp/op_app:AccountName?algorithm=SHA1&amp;digits=6&amp;issuer=op_app&amp;period=30&amp;secret=SecretKey</span><br></pre></td></tr></table></figure><ul><li>C为计数器，每次认证通过都会+1</li><li>上面采用了HMAC-SHA-1，当然也可以使用HMAC-MD5等</li><li>HMAC算法得出的值位数比较多，不方便用户输入，因此需要截断（Truncate）成为一组不太长十进制数（例如6位）。</li></ul><p><img src="/2022/09/09/%E5%9F%BA%E4%BA%8EGoogleAuthenticator%E7%9A%84MFA%E5%A4%9A%E9%87%8D%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/1.png" alt="1"></p><h3 id="TOTP"><a href="#TOTP" class="headerlink" title="TOTP"></a>TOTP</h3><p>表示基于时间戳算法的一次性密码。 即基于客户端的动态口令和动态口令验证服务器的时间进行比对，一般每30秒产生一个新口令，要求客户端和服务器能够十分精确的保持正确的时钟，客户端和服务端基于时间计算的动态口令才能一致。</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TOTP = HMAC-SHA-1(K, (T - T0) / X)</span><br></pre></td></tr></table></figure><ul><li>T0是约定的起始时间点的时间戳，默认是0，也就是1970年1月1日 00:00:00。T 是当前时间，X为时间步长，通常为30s。所以(T - T0) &#x2F; X指的是当前到1970年1月1日 00:00:00间隔多少个30s</li><li>K为双方协定的密钥</li><li>HMAC-SHA-1是约定的哈希函数</li></ul><p><img src="/2022/09/09/%E5%9F%BA%E4%BA%8EGoogleAuthenticator%E7%9A%84MFA%E5%A4%9A%E9%87%8D%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/2.png" alt="2"></p><h4 id="验证码计算"><a href="#验证码计算" class="headerlink" title="验证码计算"></a>验证码计算</h4><blockquote><p>RFC4226标准： <a href="https://datatracker.ietf.org/doc/html/rfc4226#section-5.4">https://datatracker.ietf.org/doc/html/rfc4226#section-5.4</a></p></blockquote><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func GenerateCode(secret string, counter uint64, opts ValidateOpts) (passcode string, err error) &#123;</span><br><span class="line">    // As noted in issue #10 and #17 this adds support for TOTP secrets that are</span><br><span class="line">    // missing their padding.</span><br><span class="line">    secret = strings.TrimSpace(secret)</span><br><span class="line"></span><br><span class="line">    // but the StdEncoding (and the RFC), expect a dictionary of only upper case letters.</span><br><span class="line">    secret = strings.ToUpper(secret)</span><br><span class="line"></span><br><span class="line">    secretBytes, err := base32.StdEncoding.DecodeString(secret)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return &quot;&quot;, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf := make([]byte, 8)</span><br><span class="line">    mac := hmac.New(opts.Algorithm.Hash, secretBytes)</span><br><span class="line">    binary.BigEndian.PutUint64(buf, counter)</span><br><span class="line"></span><br><span class="line">    mac.Write(buf)</span><br><span class="line">    sum := mac.Sum(nil)</span><br><span class="line"></span><br><span class="line">       // HMAC-SHA-1加密后的长度得到一个20字节的密串；</span><br><span class="line">       // 取这个20字节的密串的最后一个字节，取这字节的低4位，作为截取加密串的下标偏移量；</span><br><span class="line">       // 按照下标偏移量开始，获取4个字节，按照大端方式组成一个整数；</span><br><span class="line">       // 截取这个整数的后6位或者8位转成字符串返回。</span><br><span class="line">    // &quot;Dynamic truncation&quot; in RFC 4226</span><br><span class="line">    // http://tools.ietf.org/html/rfc4226#section-5.4</span><br><span class="line">    offset := sum[len(sum)-1] &amp; 0xf</span><br><span class="line">    value := int64(((int(sum[offset]) &amp; 0x7f) &lt;&lt; 24) |</span><br><span class="line">        ((int(sum[offset+1] &amp; 0xff)) &lt;&lt; 16) |</span><br><span class="line">        ((int(sum[offset+2] &amp; 0xff)) &lt;&lt; 8) |</span><br><span class="line">        (int(sum[offset+3]) &amp; 0xff))</span><br><span class="line"></span><br><span class="line">    l := opts.Digits.Length()</span><br><span class="line">    mod := int32(value % int64(math.Pow10(l)))</span><br><span class="line"></span><br><span class="line">    return opts.Digits.Format(mod), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h4><ul><li>由于网络延时，用户输入延迟等因素，可能当服务器端接收到一次性密码时，T的数值已经改变，这样就会导致服务器计算的一次性密码值与用户输入的不同，验证失败。解决这个问题个一个方法是，服务器计算当前时间片以及前面的n个时间片内的一次性密码值，只要其中有一个与用户输入的密码相同，则验证通过。当然，n不能太大，否则会降低安全性。</li></ul><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">counters := []uint64&#123;&#125;</span><br><span class="line">counter := int64(math.Floor(float64(t.Unix()) / float64(opts.Period)))</span><br><span class="line"></span><br><span class="line">counters = append(counters, uint64(counter))</span><br><span class="line">for i := 1; i &lt;= int(opts.Skew); i++ &#123;</span><br><span class="line">  counters = append(counters, uint64(counter+int64(i)))</span><br><span class="line">  counters = append(counters, uint64(counter-int64(i)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for _, counter := range counters &#123;</span><br><span class="line">  rv, err := hotp.ValidateCustom(passcode, counter, secret, hotp.ValidateOpts&#123;</span><br><span class="line">    Digits:    opts.Digits,</span><br><span class="line">    Algorithm: opts.Algorithm,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    return false, err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if rv == true &#123;</span><br><span class="line">    return true, nil</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h3&gt;&lt;p&gt;对于一个需要身份认证的系统而言，账号和密码是必备的，而敏感系数比较高的应用，固定的账号和密码不足以保护其安全性。通常会采集多种信息来确认当前
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go微服务-grpc与http双网关服务搭建</title>
    <link href="http://www.zhangfuguan.top/2022/05/15/go%E5%BE%AE%E6%9C%8D%E5%8A%A1-grpc%E4%B8%8Ehttp%E5%8F%8C%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.zhangfuguan.top/2022/05/15/go微服务-grpc与http双网关服务搭建/</id>
    <published>2022-05-15T14:59:44.000Z</published>
    <updated>2022-05-15T15:00:40.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建grpc环境"><a href="#搭建grpc环境" class="headerlink" title="搭建grpc环境"></a>搭建grpc环境</h1><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>我这个demo是在mac(intel)环境实现的，windows和linux大同小异，可自行在网上搜索。</p><h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><ul><li>go</li><li>buf cli</li></ul><h2 id="go"><a href="#go" class="headerlink" title="go"></a>go</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew install go</span><br><span class="line"></span><br><span class="line">go version</span><br><span class="line">go version go1.17 darwin/amd64</span><br></pre></td></tr></table></figure><h2 id="buf"><a href="#buf" class="headerlink" title="buf"></a>buf</h2><p><a href="https://docs.buf.build/installation">buf</a>其实是一种protobuf编译器，相比入传统的protoc命令行方式，buf以配置文件的方式更加方便明了。buf又有以下几个优势：</p><ul><li><a href="https://docs.buf.build/reference/internal-compiler">性能更高的Protobuf 编译器</a>。</li><li>强制执行良好的 API 设计选择和结构的 <a href="https://docs.buf.build/lint/overview">linter</a>。</li><li>在源代码或线路级别强制兼容性的<a href="https://docs.buf.build/breaking/overview">重大更改检测器。</a></li><li>基于可配置模板调用插件的<a href="https://docs.buf.build/generate/usage">生成器。</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BIN=<span class="string">&quot;/usr/local/bin&quot;</span> &amp;&amp; \</span><br><span class="line">VERSION=<span class="string">&quot;1.4.0&quot;</span> &amp;&amp; \</span><br><span class="line">  curl -sSL \</span><br><span class="line">    <span class="string">&quot;https://github.com/bufbuild/buf/releases/download/v<span class="variable">$&#123;VERSION&#125;</span>/buf-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> \</span><br><span class="line">    -o <span class="string">&quot;<span class="variable">$&#123;BIN&#125;</span>/buf&quot;</span> &amp;&amp; \</span><br><span class="line">  <span class="built_in">chmod</span> +x <span class="string">&quot;<span class="variable">$&#123;BIN&#125;</span>/buf&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.buf.build/installation">官网参考</a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ol><li>在你的工作目录创建一个文件夹用于存放项目</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdri example_grpc</span><br></pre></td></tr></table></figure><ol start="2"><li>创建以下目录结构</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">example_grpc</span><br><span class="line">  - api</span><br><span class="line">  - cmd</span><br><span class="line">  - pkg </span><br></pre></td></tr></table></figure><ol start="3"><li>初始化项目</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go mod init example_grpc</span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><ol start="4"><li>在api&#x2F;下创建api.proto文件</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> api;</span><br><span class="line"></span><br><span class="line">option go_package = <span class="string">&quot;/api&quot;</span>;</span><br><span class="line"></span><br><span class="line">service Example &#123;</span><br><span class="line">  rpc Ping(PingRequest) returns (PingResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message PingRequest &#123;&#125;</span><br><span class="line"></span><br><span class="line">message PingResponse &#123;</span><br><span class="line">  <span class="type">int32</span> Code = <span class="number">10</span>;</span><br><span class="line">  <span class="type">string</span> Msg = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>在项目根目录下创建以下buf配置文件：</li></ol><ul><li>buf.yaml<blockquote><p>配置依赖</p></blockquote></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">v1beta1</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">buf.build/adjutant/grpc_example</span></span><br><span class="line"><span class="attr">deps:</span></span><br><span class="line">  <span class="comment"># it will download this dep if you run buf generate</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">buf.build/beta/googleapis</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">buf.build/grpc-ecosystem/grpc-gateway</span></span><br></pre></td></tr></table></figure><ul><li>buf.gen.yaml<blockquote><p>指定插件和生成的文件</p></blockquote></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">v1beta1</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">go</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">opt:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">paths=source_relative</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">go-grpc</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">opt:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">paths=source_relative</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">require_unimplemented_servers=false</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grpc-gateway</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">opt:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">paths=source_relative</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">grpc_api_configuration=gw_mapping.yaml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">openapiv2</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">opt:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">grpc_api_configuration=gw_mapping.yaml</span></span><br></pre></td></tr></table></figure><ul><li>gw.mapping.yaml<blockquote><p>grpc方法和http接口路由配置</p></blockquote></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">google.api.Service</span></span><br><span class="line"><span class="attr">config_version:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Please refer google.api.Http in https://github.com/googleapis/googleapis/blob/master/google/api/http.proto file for details.</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">selector:</span> <span class="string">api.Example.Ping</span></span><br><span class="line">      <span class="attr">get:</span> <span class="string">/ping</span></span><br></pre></td></tr></table></figure><h2 id="安装go插件"><a href="#安装go插件" class="headerlink" title="安装go插件"></a>安装go插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go install \</span><br><span class="line">    github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway \</span><br><span class="line">    github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2 \</span><br><span class="line">    google.golang.org/protobuf/cmd/protoc-gen-go \</span><br><span class="line">    google.golang.org/grpc/cmd/protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><h2 id="编译proto文件"><a href="#编译proto文件" class="headerlink" title="编译proto文件"></a>编译proto文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf mod update</span><br><span class="line">buf generate</span><br></pre></td></tr></table></figure><p>执行上面两条命令之后，得到以下文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- api/</span><br><span class="line">  - api.pb.go</span><br><span class="line">  - api.gw.pb.go</span><br><span class="line">  - api.pb.go</span><br><span class="line">  - api.swagger.json</span><br></pre></td></tr></table></figure><h2 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>在cmd&#x2F;下创建main.go文件，内容为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;example_grpc/api&quot;</span></span><br><span class="line"><span class="string">&quot;example_grpc/pkg/handler&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/grpc-ecosystem/grpc-gateway/v2/runtime&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">grpcServerEndpoint = <span class="string">&quot;127.0.0.1:9091&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">go</span> toGRPC()</span><br><span class="line"><span class="keyword">go</span> toHTTP()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toGRPC</span><span class="params">()</span></span>&#123;</span><br><span class="line">s := grpc.NewServer()</span><br><span class="line"></span><br><span class="line">api.RegisterExampleServer(s, &amp;handler.Handler&#123;&#125;)</span><br><span class="line"></span><br><span class="line">lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, grpcServerEndpoint)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">&quot;net.Listen err: %+v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">&quot;s.Server err: %+v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toHTTP</span><span class="params">()</span></span>&#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register gRPC server endpoint</span></span><br><span class="line"><span class="comment">// Note: Make sure the gRPC server is running properly and accessible</span></span><br><span class="line">mux := runtime.NewServeMux()</span><br><span class="line">opts := []grpc.DialOption&#123;grpc.WithTransportCredentials(insecure.NewCredentials())&#125;</span><br><span class="line">err := api.RegisterExampleHandlerFromEndpoint(ctx, mux,  grpcServerEndpoint, opts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">&quot;RegisterLabHandlerFromEndpoint err: %+v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start HTTP server (and proxy calls to gRPC server endpoint)</span></span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:8082&quot;</span>, mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">&quot;ListenAndServe err: %+v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在pkg&#x2F;api&#x2F;下创建ping.go文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> handler</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;example_grpc/api&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Handler)</span></span> Ping(ctx context.Context, request *api.PingRequest) (*api.PingResponse, <span class="type">error</span>) &#123;</span><br><span class="line">resp := &amp;api.PingResponse&#123;</span><br><span class="line">Code: <span class="number">0</span>,</span><br><span class="line">Msg: <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl --location --request GET <span class="string">&#x27;http://127.0.0.1:8082/ping&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;Code&quot;</span>:0,<span class="string">&quot;Msg&quot;</span>:<span class="string">&quot;ok&quot;</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;搭建grpc环境&quot;&gt;&lt;a href=&quot;#搭建grpc环境&quot; class=&quot;headerlink&quot; title=&quot;搭建grpc环境&quot;&gt;&lt;/a&gt;搭建grpc环境&lt;/h1&gt;&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="微服务" scheme="http://www.zhangfuguan.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>意味</title>
    <link href="http://www.zhangfuguan.top/2022/05/09/%E6%84%8F%E5%91%B3/"/>
    <id>http://www.zhangfuguan.top/2022/05/09/意味/</id>
    <published>2022-05-09T13:40:52.000Z</published>
    <updated>2022-05-10T14:32:19.871Z</updated>
    
    <content type="html"><![CDATA[<p>长安一相见，呼我谪仙人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;长安一相见，呼我谪仙人。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="意味" scheme="http://www.zhangfuguan.top/tags/%E6%84%8F%E5%91%B3/"/>
    
  </entry>
  
  <entry>
    <title>搞定算法之快速排序</title>
    <link href="http://www.zhangfuguan.top/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.zhangfuguan.top/2021/04/14/搞定算法之快速排序/</id>
    <published>2021-04-13T16:09:06.000Z</published>
    <updated>2021-04-13T16:51:51.503Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>输入一组数组，使用快速排序算法对其进行排序</p></blockquote><ul><li>示例1</li></ul><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;5，7，2，9，10，4&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;2，4，5，7，9，10&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ol><li><p>取第一个作为基准数</p></li><li><p>将小于pri的数放在基准数的左边，将大于基准数的放在其右边</p></li><li><p>以基准数为界限，将之前的川切割成两个字串</p></li><li><p>分别对两个字串递归执行步骤1，2，3</p></li></ol><h3 id="解题思维"><a href="#解题思维" class="headerlink" title="解题思维"></a>解题思维</h3><p>对于</p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-21-35.png"></p><ol><li>pri为第一个元素值, left为第一个元素下标， right为最后一个元素下标</li></ol><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-26-25.png"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">pri = arr[left]</span><br><span class="line">right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="2"><li>从最右边开始，如果right指向的值大于则right减1，否则就将当前right所指向的值放在left位置，然后执行3。如此循环一直到left&#x3D;right.</li></ol><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-40-15.png"></p><ol start="3"><li>从最左边开始,如果right指向的值大于则right加1，否则就将当前left所指向的值放在right位置，然后执行2。如此循环一直到left&#x3D;right.</li></ol><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-42-35.png"></p><ol start="4"><li>上面循环执行的展示过程</li></ol><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-43-45.png"></p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-44-23.png"></p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-45-10.png"></p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-45-30.png"></p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-46-23.png"></p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-46-52.png"></p><ol start="5"><li>当left&#x3D;right, 那么就把基准值赋给left位置,至此就完成了把小于基准值放在左侧，大于基准值放在右侧的任务。</li></ol><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-48-02.png"></p><ol start="6"><li>然后以上面left将原数组切割成两个字串，分别递归执行上面的步骤</li></ol><h3 id="源码理解更深刻"><a href="#源码理解更深刻" class="headerlink" title="源码理解更深刻"></a>源码理解更深刻</h3><blockquote><p>强烈建议自己看懂之后手动实现一篇</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partion</span><span class="params">(arr []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">pri := arr[left]</span><br><span class="line">fmt.Printf(<span class="string">&quot;left: %d, right: %d&quot;</span>, left, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line"><span class="keyword">for</span> left &lt; right &amp;&amp; arr[right] &gt;= pri &#123;</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line">arr[left] = arr[right]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> left &lt; right &amp;&amp; arr[left] &lt;= pri &#123;</span><br><span class="line">left++</span><br><span class="line">&#125;</span><br><span class="line">arr[right] = arr[left]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">arr[left] = pri</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">par := partion(arr, left, right)</span><br><span class="line">fmt.Println(par)</span><br><span class="line"></span><br><span class="line">QuickSort(arr, left, par<span class="number">-1</span>)</span><br><span class="line">QuickSort(arr, par+<span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;输入一组数组，使用快速排序算法对其进行排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://www.zhangfuguan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="http://www.zhangfuguan.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
</feed>
