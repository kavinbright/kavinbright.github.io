<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张副官</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zhangfuguan.top/"/>
  <updated>2023-03-26T13:48:59.683Z</updated>
  <id>http://www.zhangfuguan.top/</id>
  
  <author>
    <name>张副官</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉搜索树插入于删除操作</title>
    <link href="http://www.zhangfuguan.top/2023/03/26/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E4%BA%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.zhangfuguan.top/2023/03/26/二叉搜索树插入于删除操作/</id>
    <published>2023-03-26T13:33:50.000Z</published>
    <updated>2023-03-26T13:48:59.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>二叉排序树（Binary Sarech&#x2F;Sort Tree）或者是一颗空树；或者是具有如下性质的二叉树：</p><blockquote><p>(1) 若它的左子树不空，则 <strong>左子树</strong> 上所有结点的值 <strong>均小于</strong> 它的根结点的值；<br>(2) 若它的右子树不空，则 <strong>右子树</strong> 上所有结点的值 <strong>均大于</strong> 它的根结点的值；<br>(3) 它的 <strong>左、右子树又分别为二叉排序树</strong> 。</p></blockquote><p>比如一下值: 8、3、10、1、6、14、4、7、13，构造BTS的过程如下：<br><img src="/2023/03/26/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E4%BA%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/1.jpeg"></p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Value <span class="type">string</span></span><br><span class="line">    Left *Node</span><br><span class="line">    Right *Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SearchBST 这里假设值都是int，不做异常预期判断了，咱们就简单理解算法即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchBST</span><span class="params">(targetNode *Node,value <span class="type">int</span>)</span></span> *Node &#123;</span><br><span class="line"><span class="comment">// 如果根节点为nil， 则肯定不存在</span></span><br><span class="line"><span class="keyword">if</span> targetNode ==  <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value == targetNode.Value.(<span class="type">int</span>)  &#123;</span><br><span class="line"><span class="keyword">return</span> targetNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value &lt; targetNode.Value.(<span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> SearchBST(targetNode.Left, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value &gt; targetNode.Value.(<span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> SearchBST(targetNode.Right, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertBST</span><span class="params">(targetNode *Node, value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> targetNode == <span class="literal">nil</span> &#123;</span><br><span class="line">targetNode.Value = value</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> targetNode.Value.(<span class="type">int</span>) == value &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value &lt; targetNode.Value.(<span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 如果当前节点不存在左子树，则将该目标节点作为当前节点的左子树</span></span><br><span class="line"><span class="keyword">if</span> targetNode.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">targetNode.Left = &amp;Node&#123;</span><br><span class="line">Value: value,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InsertBST(targetNode.Left, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> value &gt; targetNode.Value.(<span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 如果当前节点不存在右子树，则将该目标节点作为当前节点的右子树</span></span><br><span class="line"><span class="keyword">if</span> targetNode.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">targetNode.Right = &amp;Node&#123;</span><br><span class="line">Value: value,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">InsertBST(targetNode.Right, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除二叉搜索树的节点相对而言复杂一点，如果待删除的节点同时包含左右子树，删除后如何恢复搜索树是一个问题。<br><img src="/2023/03/26/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E4%BA%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/3.jpeg"><br>比如删除节点8， 那么是选举3作为根节点还是10呢？所以就需要我们一点点去梳理：</p><ol><li>如果删除的节点是叶子结点（即没有左右子树），那么直接删除即可，比如上面的1、7、9、13.</li><li>如果删除的节点只有左子树或者只有右子树，则删除后将子节点直接指向删除节点的位置即可，比如6、14</li><li>还有一种情况就是同时存在左右子树的情况，比如8，为了维持删除后的树依然符合二叉搜索树特性，其实可以将左子树的最大值或者右子树的最小值转移到删除点位置比如将7放在8的位置，但是这里的7是叶子结点，直接删除即可，如果7还包含左右子树，其实可以递归删除替换即可。我们可以用一个比较大的BST来举例：<br><img src="/2023/03/26/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%8F%92%E5%85%A5%E4%BA%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/2.jpeg"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteBST</span><span class="params">(node *Node, value <span class="type">int</span>)</span></span> *Node &#123;</span><br><span class="line"><span class="comment">// 如果二叉搜索树为nil，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前节点的值等于待删除值</span></span><br><span class="line"><span class="keyword">if</span> node.Value == value &#123;</span><br><span class="line"><span class="comment">// 如果当前节点没有左右子树，则直接删除</span></span><br><span class="line"><span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">node = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有右边子树，直接用右子树覆盖</span></span><br><span class="line"><span class="keyword">if</span> node.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">node = node.Right</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有左子树，直接用左子树覆盖</span></span><br><span class="line"><span class="keyword">if</span> node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">node = node.Left</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &amp;&amp; node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 找到左子树中最大值，将其设置为当前的值</span></span><br><span class="line">maxInLeft := FindMaxInNodeBST(node.Left)</span><br><span class="line">node.Value = maxInLeft.Value</span><br><span class="line">node.Left = DeleteBST(node.Left, maxInLeft.Value.(<span class="type">int</span>))</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有左子树，并且当前节点的值小于目标值，则进入左子树递归查找删除</span></span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &amp;&amp; value &lt; node.Value.(<span class="type">int</span>)  &#123;</span><br><span class="line">node.Left =  DeleteBST(node.Left, value)</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有右子树，并且当前节点的值大于目标值，则进入右子树递归查找删除</span></span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &amp;&amp; value &gt; node.Value.(<span class="type">int</span>) &#123;</span><br><span class="line">node.Right = DeleteBST(node.Right, value)</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindMaxInNodeBST</span><span class="params">(node *Node)</span></span> *Node &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树中的最大值肯定在根节点或者右子树中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果左右子树都为空，则就是当前节点</span></span><br><span class="line"><span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;二叉排序树（Binary Sarech&amp;#x2F;Sort Tree）或者是一颗空树；或者是具有如下性质的二叉树：&lt;/p&gt;
&lt;blockqu
      
    
    </summary>
    
    
      <category term="算法" scheme="http://www.zhangfuguan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://www.zhangfuguan.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历</title>
    <link href="http://www.zhangfuguan.top/2023/03/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
    <id>http://www.zhangfuguan.top/2023/03/25/二叉树遍历/</id>
    <published>2023-03-24T16:16:01.000Z</published>
    <updated>2023-03-24T16:24:12.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>前序遍历：递归遍历根-&gt;左-&gt;右</li><li>中序遍历：递归遍历左-&gt;根-&gt;右</li><li>后续遍历：递归遍历左-&gt;右-&gt;中</li><li>层序遍历：由根节点开始一层层的遍历</li></ul><p>其实前序遍历、中序遍历、后序遍历里面的前、中、后指的是根结点的位置。以下面这棵树来举例说明。<br><img src="/2023/03/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/yuque_mind.jpeg"></p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Value <span class="type">string</span></span><br><span class="line">    Left *Node</span><br><span class="line">    Right *Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>前序遍历要求先遍历根节点，然后遍历左子树，左后便利右子树。注意这里指的是【子树】不是孩子。所以遍历顺序为：<br>A,B,D,H,I,E,J,C,F,K,G</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreRange</span><span class="params">(node *Node)</span></span> []<span class="type">string</span>  &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">list := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">list = <span class="built_in">append</span>(list, node.Value)</span><br><span class="line"></span><br><span class="line">leftList := PreRange(node.Left)</span><br><span class="line"><span class="keyword">if</span> leftList != <span class="literal">nil</span> &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, leftList...)</span><br><span class="line">&#125;</span><br><span class="line">rightList := PreRange(node.Right)</span><br><span class="line"><span class="keyword">if</span> rightList != <span class="literal">nil</span> &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, rightList...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>中序遍历要求先遍历左子树，然后遍历根节点，最后遍历右子树。所以顺序为：<br>H,D,I,B,E,J,A,F,K,C,G</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MidRange</span><span class="params">(node *Node)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">list := <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line">leftList := MidRange(node.Left)</span><br><span class="line"><span class="keyword">if</span> leftList != <span class="literal">nil</span> &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, leftList...)</span><br><span class="line">&#125;</span><br><span class="line">list = <span class="built_in">append</span>(list, node.Value)</span><br><span class="line">rightList := MidRange(node.Right)</span><br><span class="line"><span class="keyword">if</span> rightList != <span class="literal">nil</span> &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, rightList...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><p>后序遍历要求先遍历左子树，然后遍历右子树，最后遍历根节点。所以顺序为：<br>H,I,D,J,E,B,K,F,G,C,A</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SufRange</span><span class="params">(node *Node)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">list := <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line">leftList := SufRange(node.Left)</span><br><span class="line"><span class="keyword">if</span> leftList != <span class="literal">nil</span> &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, leftList...)</span><br><span class="line">&#125;</span><br><span class="line">rightList := SufRange(node.Right)</span><br><span class="line"><span class="keyword">if</span> rightList != <span class="literal">nil</span> &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, rightList...)</span><br><span class="line">&#125;</span><br><span class="line">list = <span class="built_in">append</span>(list, node.Value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>层序遍历其实就是从根节点开始从左到右一层层开始遍历所有节点， 所以顺序为：<br>A,B,C,D,E,F,G,H,I,J,K</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LevelTraversal</span><span class="params">(node *Node)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nodeList := <span class="built_in">make</span>([]*Node, <span class="number">0</span>)</span><br><span class="line">nodeList = <span class="built_in">append</span>(nodeList, node)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> RecursionTraversal(nodeList)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RecursionTraversal</span><span class="params">(nodeList []*Node)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nodeList) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list := <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>)</span><br><span class="line">nextNodeList := <span class="built_in">make</span>([]*Node, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> _, node := <span class="keyword">range</span> nodeList &#123;</span><br><span class="line">list = <span class="built_in">append</span>(list, node.Value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">nextNodeList = <span class="built_in">append</span>(nextNodeList, node.Left)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">nextNodeList =<span class="built_in">append</span>(nextNodeList, node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nextNodeList) &gt; <span class="number">0</span> &#123;</span><br><span class="line">s := RecursionTraversal(nextNodeList)</span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span> &#123;</span><br><span class="line"> list = <span class="built_in">append</span>(list, s...)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方式&quot;&gt;&lt;a href=&quot;#方式&quot; class=&quot;headerlink&quot; title=&quot;方式&quot;&gt;&lt;/a&gt;方式&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://www.zhangfuguan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://www.zhangfuguan.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁方案对比</title>
    <link href="http://www.zhangfuguan.top/2023/03/03/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/"/>
    <id>http://www.zhangfuguan.top/2023/03/03/分布式锁方案对比/</id>
    <published>2023-03-02T16:15:58.000Z</published>
    <updated>2023-03-08T15:28:32.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>当我们对一份数据进行修改的时候需要先读取，再修改，由于读取和修改不是原子操作，在并发的情况下，无法保证前后数据是一致的，在单点服务中我们可以使用本地锁来实现（比如：sync.Mutex），但是对于分布式系统服务，本地锁却无能为力。这时候就需要使用分布式锁来保证数据的一致性。</p><p><img src="/2023/03/03/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/iOLsHtH8yF9PIkHbVzQntyxXNNzV7__KSfDDXUZftsk.png" alt="image"></p><p>很多应用场景是需要系统保证幂等性的（如api服务或消息消费者），并发情况下或消息重复很容易造成系统重入，那么分布式锁是保障幂等的一个重要手段。还有一种场景就是商城做抢购活动、司机抢单等场景需要使用分布式锁来防止出现“超卖”现象。</p><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><ul><li>基于数据库的唯一索引</li><li>基于redis的setnx</li><li>基于zookeeper</li></ul><h3 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h3><h4 id="基于唯一索引"><a href="#基于唯一索引" class="headerlink" title="基于唯一索引"></a>基于唯一索引</h4><p>基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含方法名（或者变量等）等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p><ul><li>新建一张表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `method_lock`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `method_lock` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `method_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;锁定的方法名&#x27;</span>,</span><br><span class="line">  `<span class="keyword">desc</span>` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注信息&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uidx_method_name` (`method_name`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;锁定中的方法&#x27;</span>;</span><br></pre></td></tr></table></figure><p>核心就是利用唯一索引的不可重复插入的特性，来控制锁的获取是释放。</p><ul><li>想要执行某个方法，就使用这个方法名向表中插入数据：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> method_lock (method_name, <span class="keyword">desc</span>) <span class="keyword">VALUES</span> (<span class="string">&#x27;methodName&#x27;</span>, <span class="string">&#x27;测试的methodName&#x27;</span>);</span><br></pre></td></tr></table></figure><p>因为我们对<code>method_name</code>做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p><ul><li>成功插入则获取锁，执行完成后删除对应的行数据释放锁：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> method_lock <span class="keyword">where</span> method_name <span class="operator">=</span><span class="string">&#x27;methodName&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</p><p>乐观锁大多数是基于数据版本(version)的记录机制实现的。何谓数据版本号？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表添加一个 “version”字段来实现读取出数据时，将此版本号一同读出，之后更新时，对此版本号加1。在更新过程中，会对版本号进行比较，如果是一致的，没有发生改变，则会成功执行本次操作；如果版本号不一致，则会更新失败。其实也可以为使用表的updated_at字段记录每次更新的时间戳，使用时间戳作为version字段。</p><p>乐观锁的优点比较明显，由于在检测数据冲突时并不依赖数据库本身的锁机制，不会影响请求的性能，当产生并发且并发量较小的时候只有少部分请求会失败。缺点是需要对表的设计增加额外的字段，增加了数据库的冗余，另外，当应用并发量高的时候，version值在频繁变化，则会导致大量请求失败，影响系统的可用性。数据库锁都是作用于同一行数据记录上，这就导致一个明显的缺点，在一些特殊场景，如大促、秒杀等活动开展的时候，大量的请求同时请求同一条记录的行锁（update），会对数据库产生很大的写压力。所以综合数据库乐观锁的优缺点，乐观锁比较适合并发量不高，并且写操作不频繁的场景。</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。</p><p>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit&#x3D;0;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">0.</span>开始事务</span><br><span class="line"><span class="keyword">begin</span>;<span class="operator">/</span><span class="keyword">begin</span> work;<span class="operator">/</span><span class="keyword">start</span> transaction; (三者选一就可以)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">1.</span>查询出商品信息</span><br><span class="line"><span class="keyword">select</span> status <span class="keyword">from</span> t_goods <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">2.</span>根据商品信息生成订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_orders (id,goods_id) <span class="keyword">values</span> (<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">3.</span>修改商品status为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> status<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">4.</span>提交事务</span><br><span class="line"><span class="keyword">commit</span>;<span class="operator">/</span><span class="keyword">commit</span> work;</span><br></pre></td></tr></table></figure><p>在悲观锁中，每一次行数据的访问都是独占的，只有当正在访问该行数据的请求事务提交以后，其他请求才能依次访问该数据，否则将阻塞等待锁的获取。悲观锁可以严格保证数据访问的安全。但是缺点也明显，即每次请求都会额外产生加锁的开销且未获取到锁的请求将会阻塞等待锁的获取，在高并发环境下，容易造成大量请求阻塞，影响系统可用性。另外，悲观锁使用不当还可能产生死锁的情况。</p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><ol><li>因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换；  </li><li>不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁；  </li><li>没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；  </li><li>不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。  </li><li>在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。</li></ol><h3 id="基于redis的setnx"><a href="#基于redis的setnx" class="headerlink" title="基于redis的setnx"></a>基于redis的setnx</h3><ol><li>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</li></ol><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SETNX &#123;ResourceURI&#125; &#123;UUID&#125;</span><br><span class="line">EXPIRE &#123;ResourceURI&#125; &#123;timeout&#125; </span><br></pre></td></tr></table></figure><ol start="2"><li>释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</li></ol><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 比对 value 与 标识</span><br><span class="line">if (redis.get(&quot;lock:168&quot;).equals(random_value))&#123;</span><br><span class="line">   redis.del(&quot;lock:168&quot;); //比对成功则删除</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h4><ol><li>setnx和expire操作的非原子特性会导致死锁问题。协程A执行setnx命令成功，结果运行协程A的服务发生异常重启，导致expire命令没有执行，那么就会由于锁没有设置超时时间形成死锁。</li><li>A线程拿到锁超时释放，但是A依旧在执行自己的业务逻辑，此时B线程立刻获得锁，B也开始执行。这显然是不被允许的，一般会采取加大过期时间或者添加守护线程，go中也可以使用context设置过期时间。</li><li>上述方案无法达到不可重入，即在同一个协程中多次加锁。可以在本地维护一个map，map的key为锁标识，value为加锁次数。 每次加锁的时候加1， 重新设置过期时间，每次释放锁的时候减1，当计数小于或等于1的时候执行删除操作删除</li></ol><h3 id="基于zookeeper"><a href="#基于zookeeper" class="headerlink" title="基于zookeeper"></a>基于zookeeper</h3><p>利用zookeeper的临时有序节点和wathcer机制来实现分布式锁的功能。具体实现步骤如下：</p><ol><li>创建一个目录lock</li><li>每个节点尝试获取锁时，首先在zookeeper的lock目录下创建一个znode节点，zookeeper的有序临时节点会自动根据创建先后顺序给节点编号。</li></ol><p><img src="/2023/03/03/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/Q8r39VsHbcEV13aoTmoBzcwJrtSP7XxGDm2s44df94Y.png" alt="image"></p><ol start="3"><li>判断当前服务节点创建的znode节点是最小节点。</li></ol><ul><li>如果序列号是最小的，则成功获取到锁。执行完操作后，把创建的节点给删掉。</li><li>如果不是，则监听比自己要小 1 的节点变化。直到拿到自己是最小的节点时获得锁。</li></ul><h4 id="缺陷-2"><a href="#缺陷-2" class="headerlink" title="缺陷"></a>缺陷</h4><p>虽然zookeeper具备高可用、可重入、阻塞锁特性，可解决失效死锁问题，但是因为需要频繁的创建和删除节点，性能上不如Redis方式。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/">小米技术团队-分布式锁的实现之 redis 篇</a></p><p><a href="https://www.cnblogs.com/liuqingzheng/p/11080501.html">刘清政的博客-分布式锁</a></p><p><a href="https://chai2010.cn/advanced-go-programming-book/ch6-cloud/ch6-02-lock.html#623-%E5%9F%BA%E4%BA%8E-redis-%E7%9A%84-setnx">go高级编程-分布式锁</a></p><p><a href="https://tech.meituan.com/2017/03/17/cache-about.html">美团技术团队-缓存那些事</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式锁&quot;&gt;&lt;a href=&quot;#分布式锁&quot; class=&quot;headerlink&quot; title=&quot;分布式锁&quot;&gt;&lt;/a&gt;分布式锁&lt;/h1&gt;&lt;p&gt;当我们对一份数据进行修改的时候需要先读取，再修改，由于读取和修改不是原子操作，在并发的情况下，无法保证前后数据是一致的，在单
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="微服务" scheme="http://www.zhangfuguan.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="高并发" scheme="http://www.zhangfuguan.top/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>璃月</title>
    <link href="http://www.zhangfuguan.top/2022/09/10/%E7%92%83%E6%9C%88/"/>
    <id>http://www.zhangfuguan.top/2022/09/10/璃月/</id>
    <published>2022-09-09T16:07:51.000Z</published>
    <updated>2022-09-09T16:31:03.259Z</updated>
    
    <content type="html"><![CDATA[<p>车遥遥，马憧憧。<br>君游东山东复东，安得奋飞逐西风。<br>愿我如星君如月，夜夜流光相皎洁。<br>月暂晦，星常明。<br>留明待月复，三五共盈盈。</p><hr><p><img src="/2022/09/10/%E7%92%83%E6%9C%88/1.png" alt="1"></p><p><img src="/2022/09/10/%E7%92%83%E6%9C%88/2.png" alt="1"></p><p><img src="/2022/09/10/%E7%92%83%E6%9C%88/3.png" alt="1"></p><p><img src="/2022/09/10/%E7%92%83%E6%9C%88/4.png" alt="1"></p><p><img src="/2022/09/10/%E7%92%83%E6%9C%88/5.png" alt="1"></p><p><img src="/2022/09/10/%E7%92%83%E6%9C%88/6.png" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;车遥遥，马憧憧。&lt;br&gt;君游东山东复东，安得奋飞逐西风。&lt;br&gt;愿我如星君如月，夜夜流光相皎洁。&lt;br&gt;月暂晦，星常明。&lt;br&gt;留明待月复，三五共盈盈。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;/2022/09/10/%E7%92%83%E6%9C%88/1.png&quot; 
      
    
    </summary>
    
    
      <category term="意味" scheme="http://www.zhangfuguan.top/tags/%E6%84%8F%E5%91%B3/"/>
    
  </entry>
  
  <entry>
    <title>基于GoogleAuthenticator的MFA多重身份认证</title>
    <link href="http://www.zhangfuguan.top/2022/09/09/%E5%9F%BA%E4%BA%8EGoogleAuthenticator%E7%9A%84MFA%E5%A4%9A%E9%87%8D%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/"/>
    <id>http://www.zhangfuguan.top/2022/09/09/基于GoogleAuthenticator的MFA多重身份认证/</id>
    <published>2022-09-08T16:22:26.000Z</published>
    <updated>2022-09-09T16:01:27.878Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>对于一个需要身份认证的系统而言，账号和密码是必备的，而敏感系数比较高的应用，固定的账号和密码不足以保护其安全性。通常会采集多种信息来确认当前访问者的身份，即多因素认证（Multi-factor authentication，MFA）,常见的多因素认证方式：</p><ul><li>短信验证码</li><li>邮件验证码</li></ul><p>上面介绍的几种方式在成本，可用性，便捷性上来说都表现不是很好，比如短信和邮件都需要收费，同时都必须保证网络在线。</p><p>Google现在也推荐用户启用两步验证（2 Factor Authentication）功能，并且除了以短信或者电话的方式发送一次性密码之外，还提供了另一种基于时间的一次性密码（Time-based One-time Password，简称TOTP），只需要在手机上安装密码生成应用程序，就可以生成一个随着时间变化的一次性密码，用于帐户验证，而且这个应用程序不需要连接网络即可工作。Google的TOTP方案其实是基于HOTP(HMAC-based One-Time Password)，所以在介绍TOTP之前先了解一下HOTP的原理。</p><h3 id="HOTP"><a href="#HOTP" class="headerlink" title="HOTP"></a>HOTP</h3><p>HOTP是一种基于散列消息验证码（HMAC）生成一次性密码值的算法，HMAC利用哈希算法，以一个密钥和一个消 息为输入，生成一个消息摘要作为输出。</p><p>进行验证时，客户端对密钥和计数器的组合(K,C)使用HMAC（Hash-based Message Authentication Code）算法计算一次性密码，公式如下：</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))</span><br></pre></td></tr></table></figure><ul><li>K为双方协定的密钥，需要自行保存，不要泄漏</li></ul><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otpauth://totp/op_app:AccountName?algorithm=SHA1&amp;digits=6&amp;issuer=op_app&amp;period=30&amp;secret=SecretKey</span><br></pre></td></tr></table></figure><ul><li>C为计数器，每次认证通过都会+1</li><li>上面采用了HMAC-SHA-1，当然也可以使用HMAC-MD5等</li><li>HMAC算法得出的值位数比较多，不方便用户输入，因此需要截断（Truncate）成为一组不太长十进制数（例如6位）。</li></ul><p><img src="/2022/09/09/%E5%9F%BA%E4%BA%8EGoogleAuthenticator%E7%9A%84MFA%E5%A4%9A%E9%87%8D%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/1.png" alt="1"></p><h3 id="TOTP"><a href="#TOTP" class="headerlink" title="TOTP"></a>TOTP</h3><p>表示基于时间戳算法的一次性密码。 即基于客户端的动态口令和动态口令验证服务器的时间进行比对，一般每30秒产生一个新口令，要求客户端和服务器能够十分精确的保持正确的时钟，客户端和服务端基于时间计算的动态口令才能一致。</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TOTP = HMAC-SHA-1(K, (T - T0) / X)</span><br></pre></td></tr></table></figure><ul><li>T0是约定的起始时间点的时间戳，默认是0，也就是1970年1月1日 00:00:00。T 是当前时间，X为时间步长，通常为30s。所以(T - T0) &#x2F; X指的是当前到1970年1月1日 00:00:00间隔多少个30s</li><li>K为双方协定的密钥</li><li>HMAC-SHA-1是约定的哈希函数</li></ul><p><img src="/2022/09/09/%E5%9F%BA%E4%BA%8EGoogleAuthenticator%E7%9A%84MFA%E5%A4%9A%E9%87%8D%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/2.png" alt="2"></p><h4 id="验证码计算"><a href="#验证码计算" class="headerlink" title="验证码计算"></a>验证码计算</h4><blockquote><p>RFC4226标准： <a href="https://datatracker.ietf.org/doc/html/rfc4226#section-5.4">https://datatracker.ietf.org/doc/html/rfc4226#section-5.4</a></p></blockquote><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func GenerateCode(secret string, counter uint64, opts ValidateOpts) (passcode string, err error) &#123;</span><br><span class="line">    // As noted in issue #10 and #17 this adds support for TOTP secrets that are</span><br><span class="line">    // missing their padding.</span><br><span class="line">    secret = strings.TrimSpace(secret)</span><br><span class="line"></span><br><span class="line">    // but the StdEncoding (and the RFC), expect a dictionary of only upper case letters.</span><br><span class="line">    secret = strings.ToUpper(secret)</span><br><span class="line"></span><br><span class="line">    secretBytes, err := base32.StdEncoding.DecodeString(secret)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return &quot;&quot;, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf := make([]byte, 8)</span><br><span class="line">    mac := hmac.New(opts.Algorithm.Hash, secretBytes)</span><br><span class="line">    binary.BigEndian.PutUint64(buf, counter)</span><br><span class="line"></span><br><span class="line">    mac.Write(buf)</span><br><span class="line">    sum := mac.Sum(nil)</span><br><span class="line"></span><br><span class="line">       // HMAC-SHA-1加密后的长度得到一个20字节的密串；</span><br><span class="line">       // 取这个20字节的密串的最后一个字节，取这字节的低4位，作为截取加密串的下标偏移量；</span><br><span class="line">       // 按照下标偏移量开始，获取4个字节，按照大端方式组成一个整数；</span><br><span class="line">       // 截取这个整数的后6位或者8位转成字符串返回。</span><br><span class="line">    // &quot;Dynamic truncation&quot; in RFC 4226</span><br><span class="line">    // http://tools.ietf.org/html/rfc4226#section-5.4</span><br><span class="line">    offset := sum[len(sum)-1] &amp; 0xf</span><br><span class="line">    value := int64(((int(sum[offset]) &amp; 0x7f) &lt;&lt; 24) |</span><br><span class="line">        ((int(sum[offset+1] &amp; 0xff)) &lt;&lt; 16) |</span><br><span class="line">        ((int(sum[offset+2] &amp; 0xff)) &lt;&lt; 8) |</span><br><span class="line">        (int(sum[offset+3]) &amp; 0xff))</span><br><span class="line"></span><br><span class="line">    l := opts.Digits.Length()</span><br><span class="line">    mod := int32(value % int64(math.Pow10(l)))</span><br><span class="line"></span><br><span class="line">    return opts.Digits.Format(mod), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h4><ul><li>由于网络延时，用户输入延迟等因素，可能当服务器端接收到一次性密码时，T的数值已经改变，这样就会导致服务器计算的一次性密码值与用户输入的不同，验证失败。解决这个问题个一个方法是，服务器计算当前时间片以及前面的n个时间片内的一次性密码值，只要其中有一个与用户输入的密码相同，则验证通过。当然，n不能太大，否则会降低安全性。</li></ul><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">counters := []uint64&#123;&#125;</span><br><span class="line">counter := int64(math.Floor(float64(t.Unix()) / float64(opts.Period)))</span><br><span class="line"></span><br><span class="line">counters = append(counters, uint64(counter))</span><br><span class="line">for i := 1; i &lt;= int(opts.Skew); i++ &#123;</span><br><span class="line">  counters = append(counters, uint64(counter+int64(i)))</span><br><span class="line">  counters = append(counters, uint64(counter-int64(i)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for _, counter := range counters &#123;</span><br><span class="line">  rv, err := hotp.ValidateCustom(passcode, counter, secret, hotp.ValidateOpts&#123;</span><br><span class="line">    Digits:    opts.Digits,</span><br><span class="line">    Algorithm: opts.Algorithm,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    return false, err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if rv == true &#123;</span><br><span class="line">    return true, nil</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h3&gt;&lt;p&gt;对于一个需要身份认证的系统而言，账号和密码是必备的，而敏感系数比较高的应用，固定的账号和密码不足以保护其安全性。通常会采集多种信息来确认当前
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go微服务-grpc与http双网关服务搭建</title>
    <link href="http://www.zhangfuguan.top/2022/05/15/go%E5%BE%AE%E6%9C%8D%E5%8A%A1-grpc%E4%B8%8Ehttp%E5%8F%8C%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.zhangfuguan.top/2022/05/15/go微服务-grpc与http双网关服务搭建/</id>
    <published>2022-05-15T14:59:44.000Z</published>
    <updated>2022-05-15T15:00:40.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建grpc环境"><a href="#搭建grpc环境" class="headerlink" title="搭建grpc环境"></a>搭建grpc环境</h1><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>我这个demo是在mac(intel)环境实现的，windows和linux大同小异，可自行在网上搜索。</p><h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><ul><li>go</li><li>buf cli</li></ul><h2 id="go"><a href="#go" class="headerlink" title="go"></a>go</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew install go</span><br><span class="line"></span><br><span class="line">go version</span><br><span class="line">go version go1.17 darwin/amd64</span><br></pre></td></tr></table></figure><h2 id="buf"><a href="#buf" class="headerlink" title="buf"></a>buf</h2><p><a href="https://docs.buf.build/installation">buf</a>其实是一种protobuf编译器，相比入传统的protoc命令行方式，buf以配置文件的方式更加方便明了。buf又有以下几个优势：</p><ul><li><a href="https://docs.buf.build/reference/internal-compiler">性能更高的Protobuf 编译器</a>。</li><li>强制执行良好的 API 设计选择和结构的 <a href="https://docs.buf.build/lint/overview">linter</a>。</li><li>在源代码或线路级别强制兼容性的<a href="https://docs.buf.build/breaking/overview">重大更改检测器。</a></li><li>基于可配置模板调用插件的<a href="https://docs.buf.build/generate/usage">生成器。</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BIN=<span class="string">&quot;/usr/local/bin&quot;</span> &amp;&amp; \</span><br><span class="line">VERSION=<span class="string">&quot;1.4.0&quot;</span> &amp;&amp; \</span><br><span class="line">  curl -sSL \</span><br><span class="line">    <span class="string">&quot;https://github.com/bufbuild/buf/releases/download/v<span class="variable">$&#123;VERSION&#125;</span>/buf-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> \</span><br><span class="line">    -o <span class="string">&quot;<span class="variable">$&#123;BIN&#125;</span>/buf&quot;</span> &amp;&amp; \</span><br><span class="line">  <span class="built_in">chmod</span> +x <span class="string">&quot;<span class="variable">$&#123;BIN&#125;</span>/buf&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.buf.build/installation">官网参考</a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ol><li>在你的工作目录创建一个文件夹用于存放项目</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdri example_grpc</span><br></pre></td></tr></table></figure><ol start="2"><li>创建以下目录结构</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">example_grpc</span><br><span class="line">  - api</span><br><span class="line">  - cmd</span><br><span class="line">  - pkg </span><br></pre></td></tr></table></figure><ol start="3"><li>初始化项目</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go mod init example_grpc</span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><ol start="4"><li>在api&#x2F;下创建api.proto文件</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> api;</span><br><span class="line"></span><br><span class="line">option go_package = <span class="string">&quot;/api&quot;</span>;</span><br><span class="line"></span><br><span class="line">service Example &#123;</span><br><span class="line">  rpc Ping(PingRequest) returns (PingResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message PingRequest &#123;&#125;</span><br><span class="line"></span><br><span class="line">message PingResponse &#123;</span><br><span class="line">  <span class="type">int32</span> Code = <span class="number">10</span>;</span><br><span class="line">  <span class="type">string</span> Msg = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>在项目根目录下创建以下buf配置文件：</li></ol><ul><li>buf.yaml<blockquote><p>配置依赖</p></blockquote></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">v1beta1</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">buf.build/adjutant/grpc_example</span></span><br><span class="line"><span class="attr">deps:</span></span><br><span class="line">  <span class="comment"># it will download this dep if you run buf generate</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">buf.build/beta/googleapis</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">buf.build/grpc-ecosystem/grpc-gateway</span></span><br></pre></td></tr></table></figure><ul><li>buf.gen.yaml<blockquote><p>指定插件和生成的文件</p></blockquote></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">v1beta1</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">go</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">opt:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">paths=source_relative</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">go-grpc</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">opt:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">paths=source_relative</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">require_unimplemented_servers=false</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">grpc-gateway</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">opt:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">paths=source_relative</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">grpc_api_configuration=gw_mapping.yaml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">openapiv2</span></span><br><span class="line">    <span class="attr">out:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">opt:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">grpc_api_configuration=gw_mapping.yaml</span></span><br></pre></td></tr></table></figure><ul><li>gw.mapping.yaml<blockquote><p>grpc方法和http接口路由配置</p></blockquote></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">google.api.Service</span></span><br><span class="line"><span class="attr">config_version:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Please refer google.api.Http in https://github.com/googleapis/googleapis/blob/master/google/api/http.proto file for details.</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">selector:</span> <span class="string">api.Example.Ping</span></span><br><span class="line">      <span class="attr">get:</span> <span class="string">/ping</span></span><br></pre></td></tr></table></figure><h2 id="安装go插件"><a href="#安装go插件" class="headerlink" title="安装go插件"></a>安装go插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go install \</span><br><span class="line">    github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway \</span><br><span class="line">    github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2 \</span><br><span class="line">    google.golang.org/protobuf/cmd/protoc-gen-go \</span><br><span class="line">    google.golang.org/grpc/cmd/protoc-gen-go-grpc</span><br></pre></td></tr></table></figure><h2 id="编译proto文件"><a href="#编译proto文件" class="headerlink" title="编译proto文件"></a>编译proto文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf mod update</span><br><span class="line">buf generate</span><br></pre></td></tr></table></figure><p>执行上面两条命令之后，得到以下文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- api/</span><br><span class="line">  - api.pb.go</span><br><span class="line">  - api.gw.pb.go</span><br><span class="line">  - api.pb.go</span><br><span class="line">  - api.swagger.json</span><br></pre></td></tr></table></figure><h2 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>在cmd&#x2F;下创建main.go文件，内容为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;example_grpc/api&quot;</span></span><br><span class="line"><span class="string">&quot;example_grpc/pkg/handler&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/grpc-ecosystem/grpc-gateway/v2/runtime&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">grpcServerEndpoint = <span class="string">&quot;127.0.0.1:9091&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">go</span> toGRPC()</span><br><span class="line"><span class="keyword">go</span> toHTTP()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toGRPC</span><span class="params">()</span></span>&#123;</span><br><span class="line">s := grpc.NewServer()</span><br><span class="line"></span><br><span class="line">api.RegisterExampleServer(s, &amp;handler.Handler&#123;&#125;)</span><br><span class="line"></span><br><span class="line">lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, grpcServerEndpoint)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">&quot;net.Listen err: %+v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">&quot;s.Server err: %+v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toHTTP</span><span class="params">()</span></span>&#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register gRPC server endpoint</span></span><br><span class="line"><span class="comment">// Note: Make sure the gRPC server is running properly and accessible</span></span><br><span class="line">mux := runtime.NewServeMux()</span><br><span class="line">opts := []grpc.DialOption&#123;grpc.WithTransportCredentials(insecure.NewCredentials())&#125;</span><br><span class="line">err := api.RegisterExampleHandlerFromEndpoint(ctx, mux,  grpcServerEndpoint, opts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">&quot;RegisterLabHandlerFromEndpoint err: %+v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start HTTP server (and proxy calls to gRPC server endpoint)</span></span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:8082&quot;</span>, mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panicf(<span class="string">&quot;ListenAndServe err: %+v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在pkg&#x2F;api&#x2F;下创建ping.go文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> handler</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;example_grpc/api&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Handler)</span></span> Ping(ctx context.Context, request *api.PingRequest) (*api.PingResponse, <span class="type">error</span>) &#123;</span><br><span class="line">resp := &amp;api.PingResponse&#123;</span><br><span class="line">Code: <span class="number">0</span>,</span><br><span class="line">Msg: <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl --location --request GET <span class="string">&#x27;http://127.0.0.1:8082/ping&#x27;</span></span><br><span class="line">&#123;<span class="string">&quot;Code&quot;</span>:0,<span class="string">&quot;Msg&quot;</span>:<span class="string">&quot;ok&quot;</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;搭建grpc环境&quot;&gt;&lt;a href=&quot;#搭建grpc环境&quot; class=&quot;headerlink&quot; title=&quot;搭建grpc环境&quot;&gt;&lt;/a&gt;搭建grpc环境&lt;/h1&gt;&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="微服务" scheme="http://www.zhangfuguan.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>意味</title>
    <link href="http://www.zhangfuguan.top/2022/05/09/%E6%84%8F%E5%91%B3/"/>
    <id>http://www.zhangfuguan.top/2022/05/09/意味/</id>
    <published>2022-05-09T13:40:52.000Z</published>
    <updated>2022-05-10T14:32:19.871Z</updated>
    
    <content type="html"><![CDATA[<p>长安一相见，呼我谪仙人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;长安一相见，呼我谪仙人。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="意味" scheme="http://www.zhangfuguan.top/tags/%E6%84%8F%E5%91%B3/"/>
    
  </entry>
  
  <entry>
    <title>搞定算法之快速排序</title>
    <link href="http://www.zhangfuguan.top/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.zhangfuguan.top/2021/04/14/搞定算法之快速排序/</id>
    <published>2021-04-13T16:09:06.000Z</published>
    <updated>2021-04-13T16:51:51.503Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>输入一组数组，使用快速排序算法对其进行排序</p></blockquote><ul><li>示例1</li></ul><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;5，7，2，9，10，4&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;2，4，5，7，9，10&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ol><li><p>取第一个作为基准数</p></li><li><p>将小于pri的数放在基准数的左边，将大于基准数的放在其右边</p></li><li><p>以基准数为界限，将之前的川切割成两个字串</p></li><li><p>分别对两个字串递归执行步骤1，2，3</p></li></ol><h3 id="解题思维"><a href="#解题思维" class="headerlink" title="解题思维"></a>解题思维</h3><p>对于</p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-21-35.png"></p><ol><li>pri为第一个元素值, left为第一个元素下标， right为最后一个元素下标</li></ol><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-26-25.png"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">pri = arr[left]</span><br><span class="line">right = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="2"><li>从最右边开始，如果right指向的值大于则right减1，否则就将当前right所指向的值放在left位置，然后执行3。如此循环一直到left&#x3D;right.</li></ol><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-40-15.png"></p><ol start="3"><li>从最左边开始,如果right指向的值大于则right加1，否则就将当前left所指向的值放在right位置，然后执行2。如此循环一直到left&#x3D;right.</li></ol><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-42-35.png"></p><ol start="4"><li>上面循环执行的展示过程</li></ol><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-43-45.png"></p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-44-23.png"></p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-45-10.png"></p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-45-30.png"></p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-46-23.png"></p><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-46-52.png"></p><ol start="5"><li>当left&#x3D;right, 那么就把基准值赋给left位置,至此就完成了把小于基准值放在左侧，大于基准值放在右侧的任务。</li></ol><p><img src="/2021/04/14/%E6%90%9E%E5%AE%9A%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/2021-04-14-00-48-02.png"></p><ol start="6"><li>然后以上面left将原数组切割成两个字串，分别递归执行上面的步骤</li></ol><h3 id="源码理解更深刻"><a href="#源码理解更深刻" class="headerlink" title="源码理解更深刻"></a>源码理解更深刻</h3><blockquote><p>强烈建议自己看懂之后手动实现一篇</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partion</span><span class="params">(arr []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">pri := arr[left]</span><br><span class="line">fmt.Printf(<span class="string">&quot;left: %d, right: %d&quot;</span>, left, right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line"><span class="keyword">for</span> left &lt; right &amp;&amp; arr[right] &gt;= pri &#123;</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line">arr[left] = arr[right]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> left &lt; right &amp;&amp; arr[left] &lt;= pri &#123;</span><br><span class="line">left++</span><br><span class="line">&#125;</span><br><span class="line">arr[right] = arr[left]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">arr[left] = pri</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(arr []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> left &lt; right &#123;</span><br><span class="line">par := partion(arr, left, right)</span><br><span class="line">fmt.Println(par)</span><br><span class="line"></span><br><span class="line">QuickSort(arr, left, par<span class="number">-1</span>)</span><br><span class="line">QuickSort(arr, par+<span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;输入一组数组，使用快速排序算法对其进行排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="http://www.zhangfuguan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="http://www.zhangfuguan.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>反转链表</title>
    <link href="http://www.zhangfuguan.top/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.zhangfuguan.top/2021/04/11/反转链表/</id>
    <published>2021-04-11T14:31:01.000Z</published>
    <updated>2021-04-13T15:22:52.397Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。</p></blockquote><ul><li>示例1</li></ul><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1,2,3&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;3,2,1&#125;</span><br></pre></td></tr></table></figure><p>直观来看对于链表：</p><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-11-23-46-30.png" alt="01"></p><p>反转后</p><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-11-23-49-49.png" alt="1"></p><h3 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h3><ol><li>其实我们本质上是把每个节点的数据之间的指向调整一下</li></ol><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-11-23-56-37.png" alt="3"></p><ol start="2"><li>通常我们使用preNode(前一个节点)，currNode(当前节点)，nextNode(当前节点)来实现遍历每个节点修改。最开始preNode指向null，currNode与nextNode指向第一个节点。</li></ol><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-12-00-14-42.png"></p><ol start="3"><li><p>现在开始第一个反转：</p><p> 将nextNode指针指向下一个节点</p><p> <img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-12-00-19-09.png"></p><p> 修改当前指针的方向</p><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-12-00-20-50.png"></p><p>方向修改完成，将pre指向当前节点</p><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-12-00-21-30.png"></p><p>将当前节点移动到下一个节点上</p><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-12-00-22-24.png"></p></li><li><p>直到currNode不为null。总结来说preNode用来维持与已经反转好的那部分的关系，nextNode是为了currNode完成方向逆转之后跳到下一个节点，currNode完成方向逆转，承接preNode。想一想如果没有nextNode行不行？</p></li></ol><h4 id="源码（golang）"><a href="#源码（golang）" class="headerlink" title="源码（golang）"></a>源码（golang）</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Link 链表</span></span><br><span class="line"><span class="keyword">type</span> Link <span class="keyword">struct</span> &#123;</span><br><span class="line">Value <span class="type">int</span></span><br><span class="line">Next  *Link</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt; preNode, curNode, nextNode</span></span><br><span class="line"><span class="comment">1. nextNode = curNode.Next</span></span><br><span class="line"><span class="comment">2. curNode.Next = preNode</span></span><br><span class="line"><span class="comment">3. preNode = curNode</span></span><br><span class="line"><span class="comment">4. curNode = nextNode</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// ReversalLink 反转链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReversalLink</span><span class="params">(head *Link)</span></span> *Link &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> preNode *Link</span><br><span class="line"><span class="keyword">var</span> nextNode *Link</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">nextNode = head.Next</span><br><span class="line">head.Next = preNode</span><br><span class="line">preNode = head</span><br><span class="line">head = nextNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> preNode</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><ol><li>以heap为起点进行反转，然后返回新链表的起点元素。</li></ol><p><img src="/2021/04/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2021-04-12-00-51-09.png"></p><ol start="2"><li>注意第一个元素需要做单独处理</li></ol><h4 id="源码（golang）-1"><a href="#源码（golang）-1" class="headerlink" title="源码（golang）"></a>源码（golang）</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Link 链表</span></span><br><span class="line"><span class="keyword">type</span> Link <span class="keyword">struct</span> &#123;</span><br><span class="line">Value <span class="type">int</span></span><br><span class="line">Next  *Link</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReversalLinkRecursion 递归反转全部链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReversalLinkRecursion</span><span class="params">(head *Link)</span></span> *Link &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;bbbb&quot;</span>)</span><br><span class="line"></span><br><span class="line">lastLink := ReversalLink(head.Next)</span><br><span class="line">fmt.Println(<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line">head.Next.Next = head</span><br><span class="line">head.Next = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> lastLink</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;输入一个链表，反转链表后，输出新链表的表头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="算法" scheme="http://www.zhangfuguan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="http://www.zhangfuguan.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>武汉大学生落户流程</title>
    <link href="http://www.zhangfuguan.top/2021/04/04/%E6%AD%A6%E6%B1%89%E5%A4%A7%E5%AD%A6%E7%94%9F%E8%90%BD%E6%88%B7%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.zhangfuguan.top/2021/04/04/武汉大学生落户流程/</id>
    <published>2021-04-04T13:39:16.000Z</published>
    <updated>2021-04-04T13:42:16.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="武汉大学生落户"><a href="#武汉大学生落户" class="headerlink" title="武汉大学生落户"></a>武汉大学生落户</h2><h3 id="大学生资格"><a href="#大学生资格" class="headerlink" title="大学生资格"></a>大学生资格</h3><p>简而言之，基本上门槛很低。</p><ul><li><p>无年龄限制人员–博士、硕士、研究生(含教育部认证的留学回国人员)学历</p></li><li><p>不满45岁人员–专科及本科学历或学位</p></li></ul><h3 id="落户流程"><a href="#落户流程" class="headerlink" title="落户流程"></a>落户流程</h3><p><img src="/2021/04/04/%E6%AD%A6%E6%B1%89%E5%A4%A7%E5%AD%A6%E7%94%9F%E8%90%BD%E6%88%B7%E6%B5%81%E7%A8%8B/wh-house01.png" alt="wh-house01"></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>准迁入证明有40个工作日的有效期</li><li>能选择邮寄就邮寄，方便很多</li></ol><h3 id="资料准备"><a href="#资料准备" class="headerlink" title="资料准备"></a>资料准备</h3><ol><li>申报户口登记表（自取链接: <a href="https://pan.baidu.com/s/1zo_mPdzedxYe4qiegV6BEw">https://pan.baidu.com/s/1zo_mPdzedxYe4qiegV6BEw</a>  密码: c9vh）</li><li>户口本首页以及本人页</li><li>学历证明（学信网开具）</li><li>毕业证原件</li><li>居住协议（租赁或借住合同）</li><li>本人照片</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;武汉大学生落户&quot;&gt;&lt;a href=&quot;#武汉大学生落户&quot; class=&quot;headerlink&quot; title=&quot;武汉大学生落户&quot;&gt;&lt;/a&gt;武汉大学生落户&lt;/h2&gt;&lt;h3 id=&quot;大学生资格&quot;&gt;&lt;a href=&quot;#大学生资格&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="生活" scheme="http://www.zhangfuguan.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="房子" scheme="http://www.zhangfuguan.top/tags/%E6%88%BF%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>每日一招之golang的append</title>
    <link href="http://www.zhangfuguan.top/2021/04/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%8B%9B%E4%B9%8Bgolang%E7%9A%84append/"/>
    <id>http://www.zhangfuguan.top/2021/04/04/每日一招之golang的append/</id>
    <published>2021-04-04T13:32:14.000Z</published>
    <updated>2021-04-04T13:32:58.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="请说出一下打印结果"><a href="#请说出一下打印结果" class="headerlink" title="请说出一下打印结果"></a>请说出一下打印结果</h3><ul><li><p>第一种</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sli := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">sli[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">sli[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">res := changeSlice(sli)</span><br><span class="line">fmt.Printf(<span class="string">&quot;sli: %+v, res: %+v \n&quot;</span>, sli, res)</span><br><span class="line"></span><br><span class="line">res[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;sli: %+v, res: %+v \n&quot;</span>, sli, res)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁  test2  go run main.go</span><br><span class="line">sli: [0 1], res: [0 1 3] </span><br><span class="line">sli: [100 1], res: [100 1 3] </span><br></pre></td></tr></table></figure><ul><li>当sli传递给函数的时候，新建了切片s。在函数中给s进行了append一个元素，由于此时s的容量足够到，并没有生成新的底层数组。当修改返回的res的时候，res与sli共用了底层的数组，因此修改ret的原始，相应的也看到了slice的改变。</li></ul></li><li><p>第二种</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sli := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">sli[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">sli[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">res := changeSlice(sli)</span><br><span class="line">fmt.Printf(<span class="string">&quot;sli: %+v, res: %+v \n&quot;</span>, sli, res)</span><br><span class="line"></span><br><span class="line">res[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;sli: %+v, res: %+v \n&quot;</span>, sli, res)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">☁  test2  go run main.go</span><br><span class="line">sli: [0 1], res: [0 1 3] </span><br><span class="line">sli: [0 1], res: [100 1 3] </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>函数中先改变s第一个元素的值，由于slice和s都共用了底层数组，因此无论原始切片slice还是ret，第一个元素都是-1.然后append操作之后，因为超出了s的容量，因此会新建底层数组，虽然s变量没变，但是他的底层数组变了，此时修改s第一个元素，并不会影响原始的slice切片。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>切片底层本质是基于数组</p></li><li><p>append的是用来向切片添加数据的，当前切片容量够的时候，append生成的心切片依然和之前的切片共享底层数组，一旦当前切片的容量不够用的时候就会另起灶炉，生成新的底层数组。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;请说出一下打印结果&quot;&gt;&lt;a href=&quot;#请说出一下打印结果&quot; class=&quot;headerlink&quot; title=&quot;请说出一下打印结果&quot;&gt;&lt;/a&gt;请说出一下打印结果&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一种&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="每日一招" scheme="http://www.zhangfuguan.top/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>利用pprof排查内存泄漏</title>
    <link href="http://www.zhangfuguan.top/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://www.zhangfuguan.top/2020/11/14/利用pprof排查内存泄漏/</id>
    <published>2020-11-14T14:54:21.000Z</published>
    <updated>2021-04-04T13:17:14.788Z</updated>
    
    <content type="html"><![CDATA[<h3 id="go技能卡：利用pprof排查内存泄漏"><a href="#go技能卡：利用pprof排查内存泄漏" class="headerlink" title="go技能卡：利用pprof排查内存泄漏"></a>go技能卡：利用pprof排查内存泄漏</h3><h4 id="浅言碎语"><a href="#浅言碎语" class="headerlink" title="浅言碎语"></a>浅言碎语</h4><blockquote><p>前几天在POC环境，我负责的一个项目的调度程序内存出现线性增长，由于我们的常驻内存程序限制最大为256MB，所以增长超过这个限制的时候就会被kill掉。</p></blockquote><p> <img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/b81ff3d4-7b11-40c8-b791-fc7654768fd6.png"></p><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/99cce23b-a5e1-4716-b702-6718911d1911.png"></p><blockquote><p>明明DEV, TEST两个环境都是正确的，为啥POC就出现异常了呢？正当我们焦头烂额的时候，想起来我之前在程序里面已经开启了pprof数据采集服务，最终我们通过pprof找到问题位置，排查发现有一位同学在for循环开启了context之后没有关闭掉，使得内存一直增长，添加闭包之后得以解决。</p></blockquote><h4 id="关于pprof"><a href="#关于pprof" class="headerlink" title="关于pprof"></a>关于pprof</h4><blockquote><p>pprof是提供应用运行状态（CPU, 内存，Goroutine, 锁等）数据和可视化分析的工具。目前pprof提供了两种方式</p></blockquote><ul><li>runtime&#x2F;pprof</li><li>net&#x2F;http&#x2F;pprof</li></ul><blockquote><p>其实<code>net/http/pprof</code>本内部也是使用<code>runtime/pprof</code>来实现，只不过是可以通过端口的方式暴露访问。本文主要讲述<code>net/http/pprof</code>的使用方法。参考<a href="%5Bhttps://pkg.go.dev/net/http/pprof%5D(https://pkg.go.dev/net/http/pprof">net&#x2F;http&#x2F;pprof</a>。</p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><blockquote><p>最简单的使用是在你的main函数里面导入<code>net/http/pprof</code>包，并监听一个端口号。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    helloHandler := <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">        io.WriteString(w, <span class="string">&quot;Hello, world!\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>让后在浏览器中访问链接：<a href="http://127.0.0.1:8080/debug/pprof/">http://127.0.0.1:8080/debug/pprof/</a>可以看到：</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/616230dd-fa1f-4151-824d-a0f714504112.png"></p><blockquote><p>下面讲述一下上面几个参数的意义</p></blockquote><p>| 类型 | 描述 |<br>| — | — | — |<br>| allocs | 内存分配情况的采样信息 |<br>| blocks | 阻塞操作情况的采样信息 |<br>| cmdline | 显示程序启动命令及参数 |<br>| goroutine | 当前所有协程的堆栈信息 |<br>| heap | 堆上内存使用情况的采样信息 |<br>| mutex | 锁争用情况的采样信息 |<br>| profile | CPU 占用情况的采样信息 |<br>| threadcreate | 系统线程创建情况的采样信息 |<br>| trace | 程序运行跟踪信息 |</p><blockquote><p>说实话上面的信息打开后可读性不高，满屏密密麻麻的字符，不仔细看根本没法找到需要的信息，此时我们可以使用<code>go tool</code>命令来查看自己需要的信息。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool http://127.0.0.1:8080/debug/pprof/指标</span><br></pre></td></tr></table></figure><blockquote><p>比如我们在cmd里面打开<code>go tool pprof http://127.0.0.1:8080/debug/pprof/allocs</code>,次数会进入待输入命令状态，如果想知道可以支持什么命令则可以输入<code>help</code>即可查看， 进一步如果想看该命令释放方法可以<code>help 命令</code>得到，比如下面输入<code>help list</code>之后：</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/a4cb0d17-6078-45d9-b37b-44178c926e08.png"></p><blockquote><p>通常情况下我们会使用<code>top</code>&#x2F;<code>top10</code>&#x2F;<code>top20</code>来查看当前指数程序占用排行。</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/afd61c47-54eb-4dbe-bca9-b33fb479abf9.png"></p><blockquote><p>如果我们需要查看具体占用位置，可以输入<code>list 关键字</code>，比如<code>list StartCPUProfile</code>:</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/0574d8b6-61c5-4979-a5ab-f343f02efe4c.png"></p><blockquote><p>此时我们就可以定位到问题了。</p></blockquote><h4 id="锦上添花"><a href="#锦上添花" class="headerlink" title="锦上添花"></a>锦上添花</h4><blockquote><p>其实使用上面的方式我们已经定位到问题位置，但是命令行终究不够直观，如果提供一个文档或者网页能够把数据统计处理统计给我们，那岂不是妙哉，现饭还是很香的。我们只能想想，而大佬早已实现，其实<code>pprof</code>已经提供了网页方式浏览。我们只需要在上面的命令添加<code>-web</code>即可。但是如果你是第一次使用，则会出现以下问题：</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/b27472ea-1e52-443a-9860-7c7380a7970b.png"></p><blockquote><p>其实是提示我们需要安装<code>Graphviz</code>,Graphviz是一个由AT&amp;T实验室启动的开源工具包，用于绘制DOT语言脚本描述的图形。我们需要安装一下，(下载地址)[<a href="https://graphviz.org/download/">https://graphviz.org/download/</a>]。</p></blockquote><blockquote><p>安装之后重新执行<code>go tool pprof -web http://127.0.0.1:8080/debug/pprof/allocs</code></p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/2682fb43-3e97-41f9-a1bf-516892043742.png"></p><blockquote><p>上面其实是在浏览器中打开文件，其实还有更好的一种方式，利用<code>pprof</code>起一个服务，可以实时看到指标信息， 执行<code>go tool pprof -web http://127.0.0.1:8080/debug/pprof/allocs</code>:</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/ec476eaa-1768-4b91-ae70-a5342ff834f4.png"></p><blockquote><p>你可以选择上面的<code>TOP</code>查看排行情况：</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/8eb61e24-b372-481d-90cb-d51292ae78a8.png"></p><blockquote><p>你还可以选择<code>Peek</code>查看调用详情：</p></blockquote><p><img src="/2020/11/14/%E5%88%A9%E7%94%A8pprof%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/832add00-e1d8-4ea4-b00f-82ca1378047c.png"></p><blockquote><p>其实还有很多功能，比如查看火焰图，查看当前数据和累计数据等。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;go技能卡：利用pprof排查内存泄漏&quot;&gt;&lt;a href=&quot;#go技能卡：利用pprof排查内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;go技能卡：利用pprof排查内存泄漏&quot;&gt;&lt;/a&gt;go技能卡：利用pprof排查内存泄漏&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go并发控制方式</title>
    <link href="http://www.zhangfuguan.top/2020/10/15/go%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.zhangfuguan.top/2020/10/15/go并发控制方式/</id>
    <published>2020-10-14T16:25:17.000Z</published>
    <updated>2021-04-04T13:33:46.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Go并发控制模型"><a href="#Go并发控制模型" class="headerlink" title="Go并发控制模型"></a>Go并发控制模型</h3><h4 id="1-Sync"><a href="#1-Sync" class="headerlink" title="1. Sync"></a>1. Sync</h4><blockquote><p>分别使用sync.WaitGroup提供的Add，Done，Wait来控制计数器</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nameList := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;zhang san&quot;</span>, <span class="string">&quot;li si&quot;</span>, <span class="string">&quot;wang wu&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="built_in">len</span>(nameList))</span><br><span class="line">    <span class="keyword">for</span> _, name := <span class="keyword">range</span> nameList &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Printf(<span class="string">&quot;name: %s \n&quot;</span>, name)</span><br><span class="line">        &#125;(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;over&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2. Channel"></a>2. Channel</h4><blockquote><p>通过channel阻塞实现</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nameList := [<span class="number">3</span>]<span class="type">string</span>&#123;<span class="string">&quot;zhang san&quot;</span>, <span class="string">&quot;li si&quot;</span>, <span class="string">&quot;wang wu&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="built_in">len</span>(nameList))</span><br><span class="line">    <span class="keyword">for</span> _, name := <span class="keyword">range</span> nameList &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- <span class="number">1</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;name: %s \n&quot;</span>, name)</span><br><span class="line">        &#125;(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待N个后台线程完成</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(ch); i++ &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;over&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Context"><a href="#3-Context" class="headerlink" title="3. Context"></a>3. Context</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)</span><br><span class="line">    go funcA(ctx)</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * 5)</span><br><span class="line">    cancel()</span><br><span class="line">    time.Sleep(time.Second * 5)</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;over&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func funcA(ctx context.Context) &#123;</span><br><span class="line">    go funcB(ctx)</span><br><span class="line">    for &#123;</span><br><span class="line">        time.Sleep(time.Second * 1)</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(&quot;funcA Stop&quot;)</span><br><span class="line">            return</span><br><span class="line">        default:</span><br><span class="line">            fmt.Println(&quot;doing funcA...&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func funcB(ctx context.Context) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        time.Sleep(time.Second * 1)</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(&quot;funcB Stop&quot;)</span><br><span class="line">            return</span><br><span class="line">        default:</span><br><span class="line">            fmt.Println(&quot;doing funcB...&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Go并发控制模型&quot;&gt;&lt;a href=&quot;#Go并发控制模型&quot; class=&quot;headerlink&quot; title=&quot;Go并发控制模型&quot;&gt;&lt;/a&gt;Go并发控制模型&lt;/h3&gt;&lt;h4 id=&quot;1-Sync&quot;&gt;&lt;a href=&quot;#1-Sync&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="并发" scheme="http://www.zhangfuguan.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>redis基本数据结构</title>
    <link href="http://www.zhangfuguan.top/2020/10/13/redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://www.zhangfuguan.top/2020/10/13/redis基本数据结构/</id>
    <published>2020-10-12T17:08:35.000Z</published>
    <updated>2021-04-04T13:17:14.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis面试系列：数据结构"><a href="#redis面试系列：数据结构" class="headerlink" title="redis面试系列：数据结构"></a>redis面试系列：数据结构</h3><blockquote><p>本文参考了《redis设计与实现》第二版</p></blockquote><h4 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h4><ul><li>常见数据类型<ul><li>string 字符串(简单动态字符串[sds],int整数)</li><li>list 列表(链表[linkedlist]，压缩表[ziplist])</li><li>hash 哈希（字典[hashtable]，压缩表[ziplist]）</li><li>set 集合（字典[hashtable], 整数集合[intset]）</li><li>zset 有序集合（跳跃表[skiplist], 压缩表[ziplist]）</li></ul></li><li>其他高级类型<ul><li>bitmap</li><li>HyperLogLog</li><li>Pub&#x2F;Sub</li><li>Geo</li><li>BloomFilter</li></ul></li></ul><p>此文主要分析常见数据结构的应用场景、实现原理。</p><h4 id="2-简单动态字符串（SDS）"><a href="#2-简单动态字符串（SDS）" class="headerlink" title="2. 简单动态字符串（SDS）"></a>2. 简单动态字符串（SDS）</h4><p>&amp;emsp;&amp;emsp;redis是基于c语言实现的，但是redis的字符串却没有直接使用c语言的string类型，而是基于自己实现的简单字符串（simple dynamic string，简称sds）。sds的数据结构如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每一个字符串对应底层的sds是由三部分组成，分别是空闲空间长度，字符串长度，保存字符串的字节数组</li><li>free表示当前空闲的字节数，即空闲空间长度</li><li>len是用来保存当前字符串使用的字节长度，通常用来表示字符串的长度</li><li>redis的字符串在sds底层是通过字节数组的方式保存在buf当中</li></ul><p>为什么redis放着c语言现成的字符串类型不用，却自己去实现一套sds呢？从sds的数据结构可以看出它具备以下几个特点：<br> <img src="/2020/10/13/redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/sds.png" alt="redis基本数据结构"></p><p>（1）有效防止缓存区溢出</p><ul><li>SDS在执行修改之前会检查空间是否足够，如果不够用会自动将空间扩展</li></ul><p>（2）获取字符串长度的复杂度为O(1)</p><ul><li>SDS本身保存了自身的长度，所以直接获取就行</li></ul><p>（3）减少内存分配次数</p><ul><li>在C语言中，每次对字符的修改涉及到长度的变动时，都会发生系统对内存的操作（申请或释放）。SDS通过空间预分配和惰性释放极大减少了对内存的操作次数。</li><li>空间预分配：每次涉及到对字符串的操作时候，SDS不仅会为其分配修改所需要的空间，还会为SDS分配额外未使用的空间。</li><li>惰性释放：字符串长度缩短之后，不需要的空间不会立刻释放，而是分配到free空间里面，下次需要的时候直接获取，不需要重新分配内存。</li></ul><p>（4）二进制安全</p><ul><li>不同于C语言特殊的字符保存格式（字符串加末尾空字符），redis的SDS不会受限于任何格式，保存时候不会发生修改，所以它可以用来保存图片，视频等二进制数据。</li></ul><h4 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h4><p>&amp;emsp;&amp;emsp;C语言本身是没有链表这一数据结构，redis是自己实现的。链表提供了搞笑的节点重排，节点访问，节点增删能力。redis的列表底层实现之一就是链表，而且redis的发布与订阅，慢查询，监视器等功能也用到了链表，redis本身使用链表来保存多个客户端的状态。<br> <img src="/2020/10/13/redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/linkedlist.png" alt="redis基本数据结构"></p><h4 id="4-字典（map）"><a href="#4-字典（map）" class="headerlink" title="4. 字典（map）"></a>4. 字典（map）</h4><p>&amp;emsp;&amp;emsp;字典数据结构广泛应用于redis的各种功能当中，包括数据库和哈希键。redis中的字典使用哈希表作为底层实现，每个字典包含了两个哈希表，一个平时使用，一个是在rehash(扩展或收缩hash表)时用到。</p><h4 id="5-跳跃表（skiplist）"><a href="#5-跳跃表（skiplist）" class="headerlink" title="5. 跳跃表（skiplist）"></a>5. 跳跃表（skiplist）</h4><p>&amp;emsp;&amp;emsp;跳跃表是一种有序的数据结构，它通过在每个节点中维持指向其他节点的指针，从而拥有快速访问其他节点的能力。redis选择跳跃表作为有序集合的底层实现之一。</p><h4 id="6-整数集合（intset）"><a href="#6-整数集合（intset）" class="headerlink" title="6. 整数集合（intset）"></a>6. 整数集合（intset）</h4><p>&amp;emsp;&amp;emsp;整数集合是集合键的底层实现之一。当一个集合只用来保存整数，并且数量不是很多的时候，redis就会选择使用整数集合来实现。</p><h4 id="7-压缩表（ziplist）"><a href="#7-压缩表（ziplist）" class="headerlink" title="7. 压缩表（ziplist）"></a>7. 压缩表（ziplist）</h4><p>&amp;emsp;&amp;emsp压缩表是列表和哈希两种数据类型的底层实现之一，压缩表是redis为了节约内存而开发的，它是由特殊编码的连续内存块组成的顺序数据结构。当一个列表只包含少量的键，并且每个键对应的值比较小的时候，redis就会使用压缩表来实现该列表。同样如果一个hash键只包含少量的值，则也会选择压缩表作为其底层实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis面试系列：数据结构&quot;&gt;&lt;a href=&quot;#redis面试系列：数据结构&quot; class=&quot;headerlink&quot; title=&quot;redis面试系列：数据结构&quot;&gt;&lt;/a&gt;redis面试系列：数据结构&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本文参考了《red
      
    
    </summary>
    
    
      <category term="redis" scheme="http://www.zhangfuguan.top/tags/redis/"/>
    
      <category term="数据库" scheme="http://www.zhangfuguan.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="http://www.zhangfuguan.top/2020/08/25/mysql%E7%B4%A2%E5%BC%95/"/>
    <id>http://www.zhangfuguan.top/2020/08/25/mysql索引/</id>
    <published>2020-08-24T16:54:11.000Z</published>
    <updated>2021-04-04T13:17:14.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mysql索引"><a href="#mysql索引" class="headerlink" title="mysql索引"></a>mysql索引</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>- 数据库与表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_test` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `x` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `y` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `index_a_b_c_d` (`a`,`b`,`c`,`d`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure><h4 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>可以把索引理解为一本书的目录，可以通过目录迅速找到自己想要的章节，本质上就是为了提高查询速度。</p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>通常使用explain来分析一条sql语句中索引使用情况。后期会有章节专门介绍explain命令的使用方法。</p><ul><li><p>用法：<code>EXPLAIN SQL</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t_users where id=1890 \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t_users</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h5 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h5><ul><li>对于重复度比较高的字段不适合做索引，比如性别，充其量就是男，女，其他，做索引作用不大。</li><li>创建合适的唯一索引</li><li>遵循最左匹配原则</li><li>对于经常用于排序（order by），分组（group by）的字段，我们可以建立索引</li><li>索引所在的列不能参与计算，不然会失效</li><li>尽量扩展索引，不要新增加索引。</li></ul><h4 id="普通索引（简单索引）"><a href="#普通索引（简单索引）" class="headerlink" title="普通索引（简单索引）"></a>普通索引（简单索引）</h4><p>最常见的索引之一，没有任何我约束。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(<span class="keyword">column</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- eg:</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_a <span class="keyword">ON</span> t_test(a);</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">explain select * from t_test <span class="built_in">where</span> a=<span class="string">&#x27;123&#x27;</span> \G;</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t_test</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: index_a</span><br><span class="line">          key: index_a</span><br><span class="line">      key_len: 153</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="联合索引（符合索引）"><a href="#联合索引（符合索引）" class="headerlink" title="联合索引（符合索引）"></a>联合索引（符合索引）</h4><p>将多个字段用于创建索引。联合索引最重要的就是最左原则，他决定索引是否生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name(column1,column2,column3...);</span><br></pre></td></tr></table></figure><h5 id="索引最左原则"><a href="#索引最左原则" class="headerlink" title="索引最左原则"></a>索引最左原则</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(column1, column2);</span><br></pre></td></tr></table></figure><p>比如表t_test拥有字段<code>x,a,b,c,d,y</code>, 现在将字段<code>a,b,c,d</code>创建为联合索引，实际上是建立了<code>a</code>，<code>a,b</code>，<code>a,b,c</code>，<code>a,b,c,d</code>四个索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_a_b_c_d <span class="keyword">ON</span> t_test(a,b,c,d);</span><br></pre></td></tr></table></figure><ul><li><p>对于联合索引，mysql会依照创建索引时的字段顺序向右匹配，直到遇到范围查询（&gt;,&lt;,between,like）就停止匹配。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> b<span class="operator">=</span><span class="number">2</span> <span class="keyword">AND</span> c<span class="operator">&gt;</span><span class="number">3</span> <span class="keyword">AND</span> d<span class="operator">=</span><span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>此时<code>c</code> 无法使用索引。</p></li><li><p>对于查询中的<code>=</code>和<code>in</code>，只要<code>WHERE</code>里面对于索引字段的是<code>a</code>，<code>a,b</code>，<code>a,b,c</code>，<code>a,b,c,d</code>四种情况之一，那么字段条件后的字段顺序是不要求的， mysql会按照你创建索引字段顺序去比对。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> b<span class="operator">=</span><span class="number">2</span> <span class="keyword">AND</span> c<span class="operator">=</span><span class="number">3</span> <span class="keyword">AND</span> d<span class="operator">=</span><span class="number">6</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> c<span class="operator">=</span><span class="number">3</span> <span class="keyword">AND</span> d<span class="operator">=</span><span class="number">6</span> <span class="keyword">AND</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> b<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul><h5 id="有几个疑问"><a href="#有几个疑问" class="headerlink" title="有几个疑问"></a>有几个疑问</h5><p>对于上面（a,b,c,d）组成的联合索引</p><ul><li><p>A：以下索引会生效吗？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a,b,c,d,x <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> b<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> x<span class="operator">=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>答案是不会生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT a,b,c,d,x FROM t_test WHERE b=1 \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t_test</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>B：以下索引会生效吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT a,b,c,d FROM t_test WHERE b=1 AND x=5;</span><br></pre></td></tr></table></figure><p>答案是会生效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> a,b,c,d <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> b<span class="operator">=</span><span class="number">1</span> \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: t_test</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: index</span><br><span class="line">possible_keys: <span class="keyword">NULL</span></span><br><span class="line">          key: index_a_b_c_d</span><br><span class="line">      key_len: <span class="number">313</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"> </span><br><span class="line">ERROR:</span><br><span class="line"><span class="keyword">No</span> query specified</span><br></pre></td></tr></table></figure></li><li><p>B生效的原因在于查询条件中只有包含索引的字段，查询内容也全部在索引字段中，所以它只需要操作索引表即可。</p><p>A不生效是因为除了操作索引表之外，还需要从数据表中拿到额外的字段数据。</p></li></ul><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name ON table_name(column);</span><br></pre></td></tr></table></figure><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `table_name` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT ,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX index_name <span class="keyword">ON</span> table_name(<span class="keyword">column</span>)</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>使用索引的时候尽量不要使用like,  在语句<code>like value%</code>时索引会生效，但是<code>like %value%</code>不会生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t_test where a like &quot;a%&quot; \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t_test</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: index_a_b_c_d</span><br><span class="line">          key: index_a_b_c_d</span><br><span class="line">      key_len: 153</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from t_test where a like &quot;%a%&quot;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t_test</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>在索引列运算会导致索引失效</p></li><li><p>如果where后面的条件字段数据类型与匹配值的类型不一致，可能会导致索引失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_test <span class="keyword">where</span> a<span class="operator">=</span>&quot;1&quot;\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: t_test</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ref</span></span><br><span class="line">possible_keys: index_a_b_c_d</span><br><span class="line">          key: index_a_b_c_d</span><br><span class="line">      key_len: <span class="number">153</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_test <span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span> \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: t_test</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ALL</span></span><br><span class="line">possible_keys: index_a_b_c_d</span><br><span class="line">          key: <span class="keyword">NULL</span></span><br><span class="line">      key_len: <span class="keyword">NULL</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">3</span> warnings (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>索引所在列的值不能为null。只有该列包含null值，则该索引列会失效。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mysql索引&quot;&gt;&lt;a href=&quot;#mysql索引&quot; class=&quot;headerlink&quot; title=&quot;mysql索引&quot;&gt;&lt;/a&gt;mysql索引&lt;/h3&gt;&lt;h4 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.zhangfuguan.top/tags/mysql/"/>
    
      <category term="索引" scheme="http://www.zhangfuguan.top/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>go内存管理</title>
    <link href="http://www.zhangfuguan.top/2020/08/16/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://www.zhangfuguan.top/2020/08/16/go内存管理/</id>
    <published>2020-08-15T16:29:58.000Z</published>
    <updated>2021-04-04T13:17:14.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GO内存管理"><a href="#GO内存管理" class="headerlink" title="GO内存管理"></a>GO内存管理</h3><h4 id="What"><a href="#What" class="headerlink" title="What ?"></a>What ?</h4><p>内存的分配，回收，释放的过程。go的内存分配基于TCMalloc的原理实现。通常我们说内存管理指的是堆（Heap）内存管理，因为栈（Stack）不需要我们关心。</p><h4 id="关于tcmalloc"><a href="#关于tcmalloc" class="headerlink" title="关于tcmalloc"></a>关于tcmalloc</h4><p>tcmalloc是一个内存管理库，全称Thread-Cache Malloc，理解为带缓存的内存管理，其实就是为每一个线程创建一个缓存，每次为线程分配内存的时候，首先判断其大小，较小的内存块（小于32K）会首先从缓存中获取，较大的才会从Head内存中分配，这样可以减少系统调用，提高效率。</p><h5 id="三个关于tcmalloc的重要概念"><a href="#三个关于tcmalloc的重要概念" class="headerlink" title="三个关于tcmalloc的重要概念"></a>三个关于tcmalloc的重要概念</h5><ul><li><p>ThreadCache：每个线程创建的时候会为其分配包含多个内存块的链表，这些内存块大小相同，你也可以理解为其实链表是对内存块按照大小进行分类。每次申请内存的时候，当申请的内存小于32k的时候，就在ThredCache选择合适的链表，然后在链表上选择空闲的内存块分配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 为线程分配ThreadCache的时候，进行一次系统调用，后续从ThreadCache上面分配内存的时候不再需要系统调用过程，极大提高了效率。</span><br><span class="line">- ThreadChahe是线程安全的，因为它为某个线程所独有，不会产生竞争。</span><br></pre></td></tr></table></figure></li><li><p>CentralCache：粗暴翻译就是”中央缓存”，其实是有点那个意思。它是进程级别的，同一进程所有线程共享。CentralCache本质上也是由空闲内存块组成的链表，当ThreadCache上空闲内存块不足的时候，CentralCache会分配给它一些；当ThredCache上面空闲的内存块过多的时，会将自身的空闲内存块返还给CentralCache。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- CentralCache是同一进程的线程共享的，所以会产生竞争，操作的时候需要添加锁。</span><br></pre></td></tr></table></figure></li><li><p>PageHead：其实是堆内存的抽象，也是由若干链表组成，每个链表包含多个Span，每个Span其实使用多个Page组成。当CentralCache不足的时候，会从PageHead中获取，PageHead会将Span分成若干个内存块，放到CentralCache中。当CentralCache空闲内存太多时，会将一部分返还给PageHeap。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- PageHeap会产生多个CentralCache竞争，所以也是需要添加锁。</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2020/08/16/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-202008122256022581597244742123.png"></p><h5 id="TCMalloc内存分配"><a href="#TCMalloc内存分配" class="headerlink" title="TCMalloc内存分配"></a>TCMalloc内存分配</h5><ul><li>小对象直接从ThredCache中分配。</li><li>中等对象从PageHead中选择合适数量的Span进行分配。</li><li>大对象则从lagre span set分配。</li></ul><hr><h4 id="GO的内存管理"><a href="#GO的内存管理" class="headerlink" title="GO的内存管理"></a>GO的内存管理</h4><p><img src="/2020/08/16/go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/38720_10.png"></p><p>GO内存管理原理是基于TCMalloc基础，GO内存管理中与之对应的三个重要组成部分包括：</p><h5 id="MHeap"><a href="#MHeap" class="headerlink" title="MHeap"></a>MHeap</h5><p>对内存的抽象依照Span Class对Span进行归类，形成树形结构。当需要分配的内存大于32K就在Mheap上面分配，首先根据申请内存的大小size得到Class szie, 进而根据Class size得到Span class, 最后根据Span class得到内存快Span。</p><h4 id="MCache"><a href="#MCache" class="headerlink" title="MCache"></a>MCache</h4><p>与TCMalloc对应的ThreadCache, 但是与ThredCache与线程绑定不同，Mcache是与逻辑处理器P绑定，因为每一个Goroutine是运行在Processor，当需要申请的内存小于32K的时候，直接从MCache中得到，而不用进过系统调用，也不与其他Goroutine产生竞争。</p><h4 id="MCentral"><a href="#MCentral" class="headerlink" title="MCentral"></a>MCentral</h4><p>与TCMalloc对应的CentralCache,作用也类似，不再赘述。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;GO内存管理&quot;&gt;&lt;a href=&quot;#GO内存管理&quot; class=&quot;headerlink&quot; title=&quot;GO内存管理&quot;&gt;&lt;/a&gt;GO内存管理&lt;/h3&gt;&lt;h4 id=&quot;What&quot;&gt;&lt;a href=&quot;#What&quot; class=&quot;headerlink&quot; title=&quot;W
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>现代语言的内存管理模型</title>
    <link href="http://www.zhangfuguan.top/2020/08/11/%E7%8E%B0%E4%BB%A3%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.zhangfuguan.top/2020/08/11/现代语言的内存管理模型/</id>
    <published>2020-08-10T16:04:31.000Z</published>
    <updated>2021-04-04T13:17:14.798Z</updated>
    
    <content type="html"><![CDATA[<h3 id="揭开现代语言内存管理的神秘面纱"><a href="#揭开现代语言内存管理的神秘面纱" class="headerlink" title="揭开现代语言内存管理的神秘面纱"></a>揭开现代语言内存管理的神秘面纱</h3><p>–译自：<a href="https://deepu.tech/memory-management-in-programming/">Deepu K Sasidharan</a>，如果你对<a href="https://www.deepu.tech/">Deepu K Sasidharan</a>的内容感兴趣可以在<a href="https://twitter.com/deepu105">twitter</a>上面关注他，随时获取最新动态。</p><h4 id="Part1-什么是内存管理？"><a href="#Part1-什么是内存管理？" class="headerlink" title="Part1 什么是内存管理？"></a>Part1 什么是内存管理？</h4><p>其实内存管理就是控制和协调应用程序访问计算机内存的过程。这是一个严肃的话题，令人困惑，因为对于很多人而言它是一个黑盒子，让人捉摸不透。</p><h4 id="What-is-it"><a href="#What-is-it" class="headerlink" title="What is it ?"></a>What is it ?</h4><p>当我们的程序运行在目标计算机上面的时候，它会通过计算机的内存（RAM）完成以下操作：</p><ul><li>加载需要执行的代码的字节数据</li><li>保存执行时会使用到的数据和结构</li><li>加载代码执行时所需要的所有运行时系统（简而言之，指的是已编译好的程序在运行时所需要的支持系统）</li></ul><p>我们的程序除了使用内存空间保存代码的字节码之外，还会使用到内存中的堆（Heap）和栈（Stack）。</p><h4 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h4><p>栈通常用于静态内存空间的申请，见名知意，它遵循先进后出的规则。</p><ul><li>由于栈FIFO的特性，存储和查找数据从栈顶开始，无需查找对比，所以速度非常快</li><li>栈是一块连续的内存区域，其地址的增长方向是向下进行的，向内存地址减小的方向增长。保存在栈上面的数据是静态并且有限的（数据的大小在编译的时候已经确定）。</li><li>与函数调用相关的数据将会以栈帧（<strong>stack frames</strong>）的形式保存，每个栈帧其实就是函数执行的环境，比如说函数每次申请一个新的变量，会将其push到栈的最顶层的块中，当函数退出的时候变量也随之销毁。</li><li>对于那些支持多线程的应用，系统将会为每一个线程创建一个栈，数据为每个线程所独有。</li><li>栈的内存管理简单明了，即由OS（系统）来完成。</li><li>保存在栈中典型的数据包括局部变量，指针和函数块。</li><li>相对于堆（Heap）而言，由于栈的大小收到限制，所以会有栈溢出的错误。</li><li>对于绝大多数的语言来说报错在栈上面的数据会有大小的限制。</li></ul><p><img src="https://i.imgur.com/7KpvEn1.gif" alt="stack in JavaScript"></p><p>JavaScript中使用的堆栈，对象存储在Heap中，并在需要时引用。</p><h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><p>不同于栈，堆通常用于动态分配内存，在堆中程序需要使用指针来查找数据。</p><ul><li>在查找数据方面堆的效率比栈慢很多，但是可存储的数据量更大。</li><li>可以将动态大小的数据存储在堆中。</li><li>同一个应用（可以理解为进程）的不同线程可以共享堆中的数据。</li><li>由于堆内存是动态的，是语言自己申请和回收，所以堆内存的管理相对棘手。</li><li>通常堆中会保存全局变量，对象，映射等负载数据结构。</li><li>当你使用的堆内存容量超过你申请的内存容量时会抛出内存溢出的错误（当然也会有其他因素导致，比如GC）。</li><li>通常而言，对于堆内存所能保存的数据容量是没有限制的，当然，它会受限于你应用所能申请的最大内存容量。</li></ul><h4 id="Why-is-it-important"><a href="#Why-is-it-important" class="headerlink" title="Why is it important?"></a>Why is it important?</h4><p>不同于硬盘，内存的容量不可能是不受限制的扩张，如果一个应用持续申请内存而不回收，那么最终将会把内存消耗殆尽，进而使系统崩溃。因此程序不能随心所欲的占用内存，这就要求程序开发者能够解决这个问题，而目前大多数语言都提供了解决这个问题的方法和途径。我们讨论的内存管理大多数情况下指的是堆的内存管理。</p><h4 id="管理内存的方法"><a href="#管理内存的方法" class="headerlink" title="管理内存的方法"></a>管理内存的方法</h4><p>语言不会默认帮你管理内存，需要你手动申请和释放对象所需要的内存。比如，C和C++，他们提供了 <code>malloc</code>, <code>realloc</code>, <code>calloc</code>方法来申请内存，提供<code>free</code>方法来释放内存空间。这些都可以帮助开发者有效的管理堆内存，并且使用指针也是有效管理堆内存的一种方法，因人而异。</p><h4 id="垃圾回收（GC）"><a href="#垃圾回收（GC）" class="headerlink" title="垃圾回收（GC）"></a>垃圾回收（GC）</h4><p>通过释放未使用的内存分配来自动管理堆内存。GC普遍用于现代语言的内存管理当中。GC会间歇式运行，因此可能会导致较小的开销，称为暂停时间。目前<strong>JVM(Java&#x2F;Scala&#x2F;Groovy&#x2F;Kotlin)</strong>, <strong>JavaScript</strong>, <strong>C#</strong>, <strong>Golang</strong>, <strong>OCaml</strong> 和 <strong>Ruby</strong> 这些语言也使用GC作为默认的内存管理方式。</p><p><img src="https://i.imgur.com/AZaR0LP.gif" alt="Mark &amp; sweep GC"></p><p>常见垃圾回收机制</p><h5 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h5><p>也称之为 <strong>Tracing GC</strong> 。它是典型的两阶段算法，首先将被引用的对象标记为“存活”，然后将处于非“存活”状态的对象销毁。<strong>JVM</strong>, <strong>C#</strong>, <strong>Ruby</strong>, <strong>JavaScript</strong>, 和<strong>Golang</strong> 都是采用这种方法。与<strong>JVM</strong>不同的是，<strong>JavaScript</strong>的V8引擎则是采用引用计数和标记清除相结合的方法实现其内存管理。这种GC方式也可以作为外部的库应用到C和C++上面。</p><h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><p>在这种方法中，每个对象在创建之初都会得到一个引用计数，当这个对象被引用时计数会加一，当删除该引用时会减一，当引用计数为0的时候，该对象就会被删除释放。引用计数并非一种非常理想的解决方法，因为它无法处理循环引用。</p><h4 id="RAII（Resource-Acquisition-is-Initialization）"><a href="#RAII（Resource-Acquisition-is-Initialization）" class="headerlink" title="RAII（Resource Acquisition is Initialization）"></a>RAII（Resource Acquisition is Initialization）</h4><p>在这种内存管理中，对象的内存分配伴随着对象从创建到销毁的整个生命周期。RAII技术被认为是C++中内存管理的最佳方法，也被<strong>Ada</strong> 和<strong>Rust</strong>所采用。</p><h4 id="自动引用计数"><a href="#自动引用计数" class="headerlink" title="自动引用计数"></a>自动引用计数</h4><p>它类似于引用计数，但是与引用计数间歇式运行不同，它是在程序编译的时候将保存和释放的指令插入到代码当中，并且当引用计数为0的时候自动清除释放，这个过程不会造成任何程序暂停。但是它也不能处理循环引用并且依赖于开发者使用特定的关键指令来处理。在<strong>Objective C</strong> &amp; <strong>Swift</strong>中采用这种方式。</p><h4 id="Ownership"><a href="#Ownership" class="headerlink" title="Ownership"></a>Ownership</h4><p>它结合了RAII和所有权模型，任何值都必须具有一个变量作为其所有者（一次只有一个所有者），当所有者超出范围时，该值将被释放以释放内存，而不管它在栈或堆内存中。它与编译时有点类似，被应用于<strong>Rust</strong>语言中，我目前还没发现其他语言使用这种方式。</p><p><img src="https://thepracticaldev.s3.amazonaws.com/i/cxs080wnnykflkmsfo9p.png" alt="Ownership in Rust"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;揭开现代语言内存管理的神秘面纱&quot;&gt;&lt;a href=&quot;#揭开现代语言内存管理的神秘面纱&quot; class=&quot;headerlink&quot; title=&quot;揭开现代语言内存管理的神秘面纱&quot;&gt;&lt;/a&gt;揭开现代语言内存管理的神秘面纱&lt;/h3&gt;&lt;p&gt;–译自：&lt;a href=&quot;https
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="系统" scheme="http://www.zhangfuguan.top/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://www.zhangfuguan.top/2020/07/15/%E9%97%AD%E5%8C%85/"/>
    <id>http://www.zhangfuguan.top/2020/07/15/闭包/</id>
    <published>2020-07-14T16:37:40.000Z</published>
    <updated>2021-04-04T13:17:14.798Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初识闭包"><a href="#初识闭包" class="headerlink" title="初识闭包"></a>初识闭包</h3><p>闭包是一种能访问当前作用域外变量的函数。</p><p>简单来说就是：使用某个函数时，依赖于该函数作用域外的环境，该函数称之为闭包。</p><p><strong>判断一下情况是否是闭包？</strong></p><ul><li><p>A</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;Jane&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;My name is &quot;</span>, name)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>B</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;Jane&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;My name is &quot;</span>, name)</span><br><span class="line">&#125;(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;Jane&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;My name is Maria&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;this is &quot;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>**A ** 是标准的闭包，闭包是用了当前函数作用域外的变量name</p><p><strong>B</strong> 不是闭包，函数内的name是自己作用域的变量，是通过参数传递进来的</p><p><strong>C</strong> 不是闭包，没有是用作用域外的环境，外部环境对其没用影响</p><h3 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h3><p><strong>判断一下程序运行的结果</strong></p><ul><li><p>A</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fac := fA(<span class="number">10</span>)</span><br><span class="line">fac()</span><br><span class="line">fac()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fA</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Println(<span class="string">&quot;i:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>B</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fbc := fB(<span class="number">10</span>)</span><br><span class="line">fbc()</span><br><span class="line">fbc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fB</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;i:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>A的结果：<br>11<br>12</p><p>B的结果：</p><p>11<br>11</p><p>A：闭包引用了外部环境的变量，也就是说共享了一个栈上面的变量，致使该变量不会立刻被销毁，延长了改变变量的生命周期。闭包对变量追加了操作，所以会累加。</p></blockquote><h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><ul><li>访问其他函数内的变量</li><li>延长变量的生命周期，保护其不备回收机制回收</li><li>避免全局变量被污染 方便调用上下文的局部变量 加强封装性。更为了高内聚、低耦合的设计思想，使用闭包可以提升开发效率，更便于维护。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;初识闭包&quot;&gt;&lt;a href=&quot;#初识闭包&quot; class=&quot;headerlink&quot; title=&quot;初识闭包&quot;&gt;&lt;/a&gt;初识闭包&lt;/h3&gt;&lt;p&gt;闭包是一种能访问当前作用域外变量的函数。&lt;/p&gt;
&lt;p&gt;简单来说就是：使用某个函数时，依赖于该函数作用域外的环境，该函数称之
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go单例模式</title>
    <link href="http://www.zhangfuguan.top/2020/07/07/go%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zhangfuguan.top/2020/07/07/go单例模式/</id>
    <published>2020-07-06T16:37:26.000Z</published>
    <updated>2021-04-04T13:17:14.786Z</updated>
    
    <content type="html"><![CDATA[<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>go最大的优势之一在于在语言层面通过goroutine实现了并发编程，提高了执行效率；但是并发随之带来的事就如何保证线程安全。通过我们会使用单例模式来保证线程安全，即在程序中我们只需要某个“类”实例化一次即可，保证一个“类“仅有一个实例，并提供一个获取实例的方法。</p><h4 id="小刀初试"><a href="#小刀初试" class="headerlink" title="小刀初试"></a>小刀初试</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instance ...</span></span><br><span class="line"><span class="keyword">type</span> Instance <span class="keyword">struct</span> &#123;</span><br><span class="line">Time <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Instance</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span></span> *Instance &#123;</span><br><span class="line"><span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">instance = &amp;Instance&#123;</span><br><span class="line">Time: time.Now().Unix(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在高并发情况下无法保证其线程的安全性。</p><h4 id="简单的锁"><a href="#简单的锁" class="headerlink" title="简单的锁"></a>简单的锁</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instance ...</span></span><br><span class="line"><span class="keyword">type</span> Instance <span class="keyword">struct</span> &#123;</span><br><span class="line">Time <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Instance</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span></span> *Instance &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">instance = &amp;Instance&#123;</span><br><span class="line">Time: time.Now().Unix(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时是可以解决并发线程安全的问题，但是每次获取实例的时候都需要经过加锁解锁的过程，造成性能不必要的损耗。</p><h4 id="再进一步"><a href="#再进一步" class="headerlink" title="再进一步"></a>再进一步</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instance ...</span></span><br><span class="line"><span class="keyword">type</span> Instance <span class="keyword">struct</span> &#123;</span><br><span class="line">Time <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Instance</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span></span> *Instance &#123;</span><br><span class="line"><span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"></span><br><span class="line">instance = &amp;Instance&#123;</span><br><span class="line">Time: time.Now().Unix(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是有在创建的时候才需要添加锁，避免不必要的锁。</p><h4 id="首选Sync-Atomic"><a href="#首选Sync-Atomic" class="headerlink" title="首选Sync.Atomic"></a>首选Sync.Atomic</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instance ...</span></span><br><span class="line"><span class="keyword">type</span> Instance <span class="keyword">struct</span> &#123;</span><br><span class="line">Time <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Instance</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span></span> *Instance &#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">instance = &amp;Instance&#123;</span><br><span class="line">Time: time.Now().Unix(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题外话：Sync-Once原理"><a href="#题外话：Sync-Once原理" class="headerlink" title="题外话：Sync.Once原理"></a>题外话：Sync.Once原理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Once is an object that will perform exactly one action.</span></span><br><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// done indicates whether the action has been performed.</span></span><br><span class="line"><span class="comment">// It is first in the struct because it is used in the hot path.</span></span><br><span class="line"><span class="comment">// The hot path is inlined at every call site.</span></span><br><span class="line"><span class="comment">// Placing done first allows more compact instructions on some architectures (amd64/x86),</span></span><br><span class="line"><span class="comment">// and fewer instructions (to calculate offset) on other architectures.</span></span><br><span class="line">done <span class="type">uint32</span></span><br><span class="line">m    Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">0</span> &#123; <span class="comment">// check</span></span><br><span class="line"><span class="comment">// Outlined slow-path to allow inlining of the fast-path.</span></span><br><span class="line">o.doSlow(f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span></span> doSlow(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">o.m.Lock()                          <span class="comment">// lock</span></span><br><span class="line"><span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> o.done == <span class="number">0</span> &#123;                    <span class="comment">// check</span></span><br><span class="line"><span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用互斥锁实现原子操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h4&gt;&lt;p&gt;go最大的优势之一在于在语言层面通过goroutine实现了并发编程，提高了执行效率；但是并发随之带来的事就如何保证线程安全
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="channel" scheme="http://www.zhangfuguan.top/tags/channel/"/>
    
      <category term="设计模式" scheme="http://www.zhangfuguan.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>go-channel</title>
    <link href="http://www.zhangfuguan.top/2020/06/14/go-channel/"/>
    <id>http://www.zhangfuguan.top/2020/06/14/go-channel/</id>
    <published>2020-06-14T15:44:27.000Z</published>
    <updated>2021-04-04T13:17:14.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Golang中channel总结"><a href="#Golang中channel总结" class="headerlink" title="Golang中channel总结"></a>Golang中channel总结</h3><hr><p>golang里面倡导的是“通过通信来共享内存”，简单来说channel是groutine之间通信的桥梁。</p><h4 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h4><ul><li>声明</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无缓冲channel</span></span><br><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> DataType)</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> DataType</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有缓冲channel</span></span><br><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> DataType, n)</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> DataType</span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> DataType, n)</span><br></pre></td></tr></table></figure><ul><li>发送与接收</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int)</span><br><span class="line">// 发送</span><br><span class="line">ch &lt;- 1</span><br><span class="line"></span><br><span class="line">// 接收</span><br><span class="line">n := &lt;- ch</span><br></pre></td></tr></table></figure><ul><li><p>注意：channel是goroutine之间通信的机制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：<code>fatal error: all goroutines are asleep - deadlock!</code></p><p>channel是不同goroutine之间通信的机制，同一个goroutine里面发送和接收是会造成阻塞的。修改如下就没问题了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ch := make(chan int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">ch &lt;- 1</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-无缓冲channel与有缓冲channel"><a href="#2-无缓冲channel与有缓冲channel" class="headerlink" title="2. 无缓冲channel与有缓冲channel"></a>2. 无缓冲channel与有缓冲channel</h4><h5 id="2-1-关于阻塞"><a href="#2-1-关于阻塞" class="headerlink" title="2.1 关于阻塞"></a>2.1 关于阻塞</h5><ul><li>无缓冲channel的发送和接收是同步的</li><li>无缓冲channel的接收在发送之前阻塞</li><li>在已经包含数据的无缓冲channel的发送在接收之前阻塞</li><li>有缓冲channel的发送和接收可以是异步的</li><li>当有缓冲channel队列满了时，发送阻塞</li><li>当有缓冲channel为空时，接收阻塞</li></ul><h5 id="2-2-关闭之后操作"><a href="#2-2-关闭之后操作" class="headerlink" title="2.2 关闭之后操作"></a>2.2 关闭之后操作</h5><ul><li><p>重复关闭 channel 会导致 panic。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: close of closed channel</span><br></pre></td></tr></table></figure></li><li><p>向关闭的 channel 发送数据会 panic。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: send on closed channel</span><br></pre></td></tr></table></figure></li><li><p>从关闭的 channel 读数据不会 panic，读出 channel 中已有的数据之后再读就是 channel 类似的默认值，比如 chan int 类型的 channel 关闭之后读取到的值为 0。</p></li></ul><h4 id="3-channel死锁的几种常见情况"><a href="#3-channel死锁的几种常见情况" class="headerlink" title="3. channel死锁的几种常见情况"></a>3. channel死锁的几种常见情况</h4><ul><li><p>同一个goroutine中对同一个channel进行读写操作（上面已经提到）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在两个以上的goroutine中，channel的读写早于goroutine的创建。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch &lt;- <span class="number">12</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多个goroutine使用多个channel进行通信，channel之前互相等待对方状态造成死锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ch1 := make(chan int)</span><br><span class="line">ch2 := make(chan int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-ch1:</span><br><span class="line">ch2 &lt;- 2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-ch2:</span><br><span class="line">ch1 &lt;- 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-channel常见用法"><a href="#3-channel常见用法" class="headerlink" title="3. channel常见用法"></a>3. channel常见用法</h4><h5 id="3-1-通信"><a href="#3-1-通信" class="headerlink" title="3.1 通信"></a>3.1 通信</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-range遍历"><a href="#3-2-range遍历" class="headerlink" title="3.2  range遍历"></a>3.2  range遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ch := make(chan int, 3)</span><br><span class="line">go func() &#123;</span><br><span class="line">for i := 1; i &lt; 4; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(ch)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">for c := range ch &#123;</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range c</code>产生的迭代值为Channel中发送的值，它会一直迭代直到channel被关闭。上面的例子中如果把<code>close(c)</code>注释掉，程序会一直阻塞在<code>for …… range</code>那一行。</p><h5 id="3-3-超时处理"><a href="#3-3-超时处理" class="headerlink" title="3.3 超时处理"></a>3.3 超时处理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ch := make(chan int)</span><br><span class="line">go func() &#123;</span><br><span class="line">time.Sleep(time.Second * 6)</span><br><span class="line">ch &lt;- 99</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case re := &lt;-ch:</span><br><span class="line">fmt.Println(&quot;ch: &quot;, re)</span><br><span class="line">case &lt;-time.After(time.Second * 5):</span><br><span class="line">fmt.Println(&quot;timeout&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用time.After()返回一个类型为<code>&lt;-chan Time</code>的单向的channel。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Golang中channel总结&quot;&gt;&lt;a href=&quot;#Golang中channel总结&quot; class=&quot;headerlink&quot; title=&quot;Golang中channel总结&quot;&gt;&lt;/a&gt;Golang中channel总结&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;golang里面倡
      
    
    </summary>
    
    
      <category term="go" scheme="http://www.zhangfuguan.top/tags/go/"/>
    
      <category term="channel" scheme="http://www.zhangfuguan.top/tags/channel/"/>
    
  </entry>
  
</feed>
